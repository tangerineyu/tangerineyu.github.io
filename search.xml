<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>接口型函数</title>
      <link href="/2025/12/18/%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/"/>
      <url>/2025/12/18/%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>最近在写极客兔兔的<a href="https://geektutu.com/post/geecache-day2.html">GeeCache</a>这个小项目，在里面遇到了一段不太理解的代码，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A GetterFunc implements Getter with a function.</span></span><br><span class="line"><span class="keyword">type</span> GetterFunc <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get implements Getter interface function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f GetterFunc)</span></span> Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> f(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合<a href="https://geektutu.com/post/7days-golang-q1.html">兔兔的讲解</a>,写一篇博客</p><blockquote><p>本质是实现多态</p></blockquote><p>接口只有一个方法，为什么不直接使用GetterFunc作为参数传进参数？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFromSource</span><span class="params">(fn GetterFunc, key <span class="type">string</span>)</span></span> []<span class="type">byte</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这意味着它只能接受函数，而不能接受一个更复杂的类型，比如一个带有内部连接状态的数据库连接对象DB<br>我只能这样用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetFromSource(<span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;xxx&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>而不能使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">GetFromSource(<span class="built_in">new</span>(DB), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果使用接口型函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GetterFunc <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f GetterFunc)</span></span> Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> f(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在就可以传函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetFromSource(GetterFunc(<span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;hi&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>传结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetFromSource(<span class="built_in">new</span>(DB), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>传普通函数（转换为GetterFunc）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line">GetFromSource(GetterFunc(fetch), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言圣经第三章</title>
      <link href="/2025/12/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AC%A6%E5%8F%B7/"/>
      <url>/2025/12/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="3-1-整型">3.1 整型</h3><p>^操作符在go中有两个作用：</p><ol><li>作为两元操作符时：x ^ y，按位异或，不同为1,相同为0</li><li>作为前置应让运算符：^y，按位取反</li></ol><p>&amp;^: z= x &amp;^ y, 如果y在某个位置是1,就把x对应位置的数归零，如果y在某个位置是0,x对应的数字不变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]o %#[1]o\n&quot;</span>, o)</span><br></pre></td></tr></table></figure><ul><li>%[1]o: 以八进制打印第一个参数，[1]的意思是读取第一个参数，好处是不用多次传同一个参数</li><li>#： 对于对应进制会在前面强制补零</li></ul><p>字符使用%c打印，带单引号的字符使用%q打印</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ascii := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">unicode := <span class="string">&#x27;国&#x27;</span></span><br><span class="line">newline := <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]c %[1]q\n&quot;</span>, ascii)   <span class="comment">// &quot;97 a &#x27;a&#x27;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]c %[1]q\n&quot;</span>, unicode) <span class="comment">// &quot;22269 国 &#x27;国&#x27;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]q\n&quot;</span>, newline)       <span class="comment">// &quot;10 &#x27;\n&#x27;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-浮点数">3.2 浮点数</h3><p>math提供了正无穷和负无穷，用于表示太大溢出的数字和除零的结果，以及NaN非数，一般用于表示无效的除法操作，或者Sqrt(-1)</p><h3 id="3-4-布尔型">3.4 布尔型</h3><p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值</p><p>&amp;&amp;的优先级比||高（助记：&amp;&amp;对应逻辑乘法，||对应逻辑加法，乘法比加法优先级要高）</p><h3 id="3-5-字符串">3.5 字符串</h3><p>字符串是不可变的，不可边指的是无法修改底层存放数据的区域，但是可以让变量指向一块新的内存区域</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;left foot&quot;</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">&quot;, right foot&quot;</span></span><br></pre></td></tr></table></figure><p>t := s 发生了一次浅拷贝，只复制了s的结构体，s,t都指向同一个内存块，这是字符串拷贝非常快的原因，不用复制底层数据</p><p><code>s += &quot;, right foot&quot;</code>，在内存中找一个新地址，先把旧数据复制过去，然后再把新的数据追加过去，然后更新s，最后的结果就是，s指向了新的地址，t指向的还是原来的地址</p><p>ASCII控制代码转义方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a      响铃</span><br><span class="line">\b      退格</span><br><span class="line">\f      换页</span><br><span class="line">\n      换行</span><br><span class="line">\r      回车</span><br><span class="line">\t      制表符</span><br><span class="line">\v      垂直制表符</span><br><span class="line">\&#x27;      单引号（只用在 &#x27;\&#x27;&#x27; 形式的rune符号面值中）</span><br><span class="line">\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）</span><br><span class="line">\\      反斜杠</span><br></pre></td></tr></table></figure><p>UTF-8<br>定长编码（UTF-32）：不管是字母A，还是复杂的汉字，通通占用4个字节，这很浪费空间<br>变长编码（UTF-8）：<br>如果是 ASCII 字符（英文、数字）：只占用 1 个字节。<br>如果是 常用字符（比如部分欧洲文字）：占用 2 个字节。<br>如果是 汉字、日文：通常占用 3 个字节。<br>如果是 Emoji 表情：占用 4 个字节。</p><p>UTF-8利用每个字节的前面几位来标识这个字节是否读完了</p><ul><li>以0开头：告诉电脑结束了，这是一个完整的字符，保证了兼容性，可以兼容老旧的ASCII文件</li><li>多个字节：<ul><li>110：表示后面还有一个字节（2字节）</li><li>1110：后面还有2个字节（3字节）</li><li>11110：后面还有3个字节（4字节）<br>后续的字节以10开头</li></ul></li></ul><p>UTF8解码：显式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%c\n&quot;</span>, i, r)</span><br><span class="line">    i += size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用`DecodeRuneInString返回两个值，r是字符本身，size对应r在采用UTF-8编码后的编码字节数目<br>隐式：Go的range循环，在处理字符串的时候，会自动隐式解码</p><blockquote><p>如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)             <span class="comment">// x is an int</span></span><br><span class="line">y, err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// base 10, up to 64 bits</span></span><br></pre></td></tr></table></figure><h3 id="3-6-常量">3.6 常量</h3><ul><li>iota常量生成器<br>第一个声明的常量所在的行，itoa为0, 然后在每一个有声明的行+1</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>原文： “对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，无类型整数常量转换为int，它的内存大小是不确定的”</p></blockquote><p><em><strong>写一个整数不告诉go是什么类型的时候，go会默认转为int类型，int是一个平台相关类型，<br>在32位系统， int = int32，<br>在64位系统，int = int64</strong></em></p><blockquote><p>原文： “但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128&quot;</p></blockquote><p>go中没有像int那样的通用float类型，所以无论是32还是64位的系统，永远转化为float64</p><p><strong>为什么区别对待？</strong></p><ul><li>整数通常用于数组下标，循环计数，这些操作依赖机器的字长</li><li>科学计算和数值算法对精度极其敏感。如果在 32 位机器上默认是 float32（精度低），而在 64 位机器上默认是 float64（精度高）。那么对科学计算的影响很大</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2025/11/29/%E7%BC%93%E5%AD%98/"/>
      <url>/2025/11/29/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h4 id="缓存雪崩：">缓存雪崩：</h4><p>缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</p><h4 id="缓存击穿：">缓存击穿：</h4><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</p><h4 id="缓存穿透：">缓存穿透：</h4><p>查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</p><ul><li>解决方案：SingleFlight（单次飞行）</li></ul><p>无论有多少个并发请求问同一个 Key，在“缓存失效”的那个瞬间，我只放一个请求去查数据库。其他请求全部阻塞等待，等第一个请求查回来，大家共享这个结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2025/11/16/JWT/"/>
      <url>/2025/11/16/JWT/</url>
      
        <content type="html"><![CDATA[<p>JWT(JSON Web Token)是一个自包含，可签名额字符串，常用于鉴权<br>结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">HEADER</span><span class="selector-class">.PAYLOAD</span><span class="selector-class">.SIGNATURE</span></span><br></pre></td></tr></table></figure><p><em>HEADER</em>：描述算法如HS256<br><em>Patload(Claims)</em>: 放自定义字段和标准字段，比如用户ID，过期时间，这个是外部可读的<br><em>Signature</em>：对 header+payload 用密钥/私钥签名，保证不可篡改</p><ul><li>AccessToken: 短期，用于日常访问，包含用户信息</li><li>RefreshToken： 长期，用于换新的accessToken，包含少量信息</li></ul><p><strong>JWT工作流程</strong>: 用户登录服务器，后端签发accessToken和refreshToken，前端保存token，每次访问接口时带上token，后端验证accessToken,通过则返回数据，如果accessToken过期了，前端自动使用RefreshToken获取新的accessToken，如果refreshToken也过期了，用户要重新登陆</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go</title>
      <link href="/2025/11/15/gogogo/"/>
      <url>/2025/11/15/gogogo/</url>
      
        <content type="html"><![CDATA[<p>思来想去，最后还是决定放弃java去写go了，一方面是java确实比较卷，卷王扎堆，但是更主要的还是自己不喜欢写java。<br>自己最早其实从7月的时候就有这个想法了，但是当时没有下定决心，而且当时在学cs61b，这门课使用java，所以当时的决定还是继续java，后面开学了开始学框架，看黑马写项目，结果越来越焦虑，经常写着写着就破防了，当时对java就很讨厌了，但是考虑到自己已经学了不少java的技术栈，有一个沉没成本的问题，还是硬着头皮写了一个月把苍穹外卖做了，最后痛苦越来越多，我对学习java已经没有任何兴趣，完全是焦虑驱动学习，在最后一次破防摆烂了几天后，决定转go，那天是11月8号，到现在9天，用了2天学了基础的语法，然后简单的了解了一些go的爬虫，就开始学gin和gorm，之后开始用框架错了一个简单的备忘录后端，这几天的感觉前所未有的好，只能说为什么不早点去学go</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2025/11/15/kmp/"/>
      <url>/2025/11/15/kmp/</url>
      
        <content type="html"><![CDATA[<p><strong>解决在主串中快速匹配子串的问题</strong><br>传统暴力算法每次失败都要从头开始，时间复杂度是$$ O(m * n) $$,效率比较差</p><blockquote><p>核心思想：利用已经匹配过的信息，避免主串指针回退，从而加速匹配<br><em><strong>KMP是如何实现优化的呢？</strong></em></p></blockquote><ul><li>前缀表<br><code>next[i] = 当 needle[0..i]</code>不匹配时，应跳回的下一个可匹配位置（前缀长度）</li></ul><p>假设我们匹配：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">主串：  ABC ABCDAB ABCDABCDABDE</span><br><span class="line">子串：     ABCDABD</span><br><span class="line"></span><br><span class="line">当匹配到：</span><br><span class="line"></span><br><span class="line">ABCDAB <span class="strong">**E**</span></span><br><span class="line">ABCDAB <span class="strong">**D**</span></span><br><span class="line"></span><br><span class="line">在 E != D 时：</span><br><span class="line"></span><br><span class="line">暴力算法会回到开头：</span><br><span class="line">   ABCDAB E</span><br><span class="line">-&gt; A</span><br></pre></td></tr></table></figure><p>但 KMP 会使用 next 数组得知：</p><p>已匹配的 “ABCDAB” 中前缀和后缀的最长相等部分是 “AB”（长度 2）</p><p>所以只需跳回到 needle[2] 继续匹配，而无须重来。</p><p>这大幅减少了重复比较。</p><blockquote><p><em><strong>为什么next数组可以帮助跳位置</strong></em><br>因为next[i]表示的是以 i 为结尾的子串中，最长相等前后缀的长度<br>当子串和主串遇到不相等的字符时，子串会回到前缀的后一个位置与主串继续比较</p></blockquote><hr><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">一个例题</a></p><ul><li>构造next数组,找出模式串内每个位置 i 的最长前后缀</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j] &#123;</span><br><span class="line">        j = next[j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>利用next进行匹配,当遇到不匹配：使用 next 数组跳转，而不是暴力回退</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(haystack); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j] &#123;</span><br><span class="line">        j = next[j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> haystack[i] == needle[j] &#123;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> j == n &#123;</span><br><span class="line">        <span class="keyword">return</span> i - n + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu挂载新分区</title>
      <link href="/2025/11/14/ubuntu%E6%96%B0%E5%A2%9E%E6%8C%82%E8%BD%BD%E5%8D%B7/"/>
      <url>/2025/11/14/ubuntu%E6%96%B0%E5%A2%9E%E6%8C%82%E8%BD%BD%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<p>我使用的是windows11与ubuntu22.04双系统，当时装ubuntu的时候还是以windows做主力的，所以内存只分了100G，现在ubuntu使用的越来越多，windows好几天才启动一次，100G的空间有点不够用了，就想扩容一下<br>最开始还是想直接分到根目录下的，找了找教程，有点麻烦，而且有挺大的风险，于是就找了这个替代方案</p><ul><li><p>从windows压缩空间：<br><code>win + x</code>进入磁盘管理，找到空闲空间比较大的盘，右键选择压缩卷，输入想要给ubuntu的空间大小<br>点击压缩，等待一会就可以看间出现了一块未分配的空间</p></li><li><p>在ubuntu上挂载：<br>打开disks，可以看见在windows创建出来的未分配空间，<br>点击下面的+创建新分区<br>创建分区时类型要选择Ext4</p></li><li><p>设置自动挂载<br>点击刚刚设置好得分区下面的齿轮图标，选择“编辑挂载选项”，关闭用户会话默认设置，勾选“在系统启动时挂载”，命名挂载点，确定</p></li><li><p>新挂载的分区默认只有root才能写入，所以要修改所有权<br><code>sudo mkdir 挂载点</code><br><code>sudo mount -a</code>挂载新分区<br><code>sudo chown -R username:username /你的挂载点的名称</code><br>重启一下，应该可以看见新的文件夹了</p></li><li><p>现在的系统盘与新挂载得分区还是隔离的，所以要自己主动管理大文件</p><p>可以把Downloads,Pictures，以及自己的项目等文件移动到新分区中<br><strong>不要移动apt或snap安装的程序</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这个命令会把 Downloads 文件夹“剪切”到 /mnt/data/</span><br><span class="line">mv ~/Downloads /mnt/data/</span><br><span class="line"># ln -s [真实文件位置] [你想创建的快捷方式位置]</span><br><span class="line">ln -s /mnt/data/Downloads ~/Downloads</span><br></pre></td></tr></table></figure><blockquote><p><em>创建分区类型时，如果我选择与windows共用，NTFS类型，会有什么缺点</em></p></blockquote><ul><li>最大的问题，没有Linux权限，当你把一个 NTFS 分区挂载到 Ubuntu 时，为了“兼容”，Linux 会“假装”所有文件都有权限，通常会把它们全部显示为 rwxrwxrwx (所有人可读可写可执行)<br>这将导致一系列问题</li><li>上面的“符号链接”方案将会失败</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>reset</title>
      <link href="/2025/10/26/reset/"/>
      <url>/2025/10/26/reset/</url>
      
        <content type="html"><![CDATA[<p>前些天一直在学苍穹外卖，一开始只是因为redis的测试一直无法运行，就照着ai一顿瞎搞，最后成功的把代码弄乱了，想着reset到上次提交的版本吧，自己当时有点后悔为什么没有多commit几次，基本是3天的内容没了，不过也还好，但是的自己很快就接受了。自己对回滚的操作并不熟悉，就再次询问AI，再次相信了它，结果执行了clean命令，删除了一些文件，导致项目再次无法启动，当时以为这个项目彻底废了，直接破防，玩了两天别的东西，今天抢救一下，还好只是丢了一些修改，无伤大雅。<br>这次也是涨个教训吧，一定要多commit，还有就是不要无脑信ai的话，因为自己的描述可能有问题，它不了解实际场景。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2025/10/25/docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/10/25/docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="docker与虚拟机的区别">docker与虚拟机的区别</h3><p>虚拟机是模拟硬件创建虚拟操作系统，运行多个虚拟机就是运行多个操作系统，docker还是使用宿主机的操作系统</p><h3 id="容器与镜像">容器与镜像</h3><ul><li>镜像是程序安装包，容器是运行中的程序，一个镜像可以run出多个容器</li></ul><h3 id="常用命令">常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们可以使用</span></span><br><span class="line">docker pull images</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从仓库下载到本地，要启动镜像的容器输入`run`命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前容器列表</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启停止状态的容器</span></span><br><span class="line">docker start &lt;容器名称/容器ID&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止容器直接输入stop命令</span></span><br><span class="line"> docker stop &lt;容器名称/容器ID&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除：</span></span><br><span class="line">docker rm &lt;容器名称/容器ID&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">容器在停止后自动删除，我们可以在运行时添加--<span class="built_in">rm</span>参数：</span></span><br><span class="line">docker run --rm 镜像名称</span><br></pre></td></tr></table></figure><h3 id="构建镜像">构建镜像</h3><h4 id="dockerfile">dockerfile</h4><ul><li>FROM：<br>一个dockerfile必须以FROM指令开始<br>作用：指定基础镜像</li><li>COPY<br>作用：将你宿主机 (你电脑) 上的文件或目录，复制到镜像内部。</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式: COPY [宿主机路径] [镜像内路径]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/demo1-0.0.1-SNAPSHOT.jar app.jar</span></span><br></pre></td></tr></table></figure><ul><li>RUN<br>作用：在构建镜像的过程中，执行 shell 命令（比如安装软件）。</li><li>EXPOSE<br>作用：声明这个容器在运行时，会监听哪个端口。</li><li>ENTRYPOINT：定义容器的“主程序（入口）”。</li><li>CMD：定义默认参数。<br>如果 ENTRYPOINT 存在，CMD 的内容会作为参数传给 ENTRYPOINT。如果 ENTRYPOINT 不存在，CMD 才会作为主程序。</li></ul><h3 id="容器网络类型">容器网络类型</h3><p>docker安装后，会创建三个网络<br>使用<code>network ls</code>查看<br>可以看到默认情况下有bridge、host、none这三种网络类型</p><ul><li>none：本地环回网络，无法连接互联网</li><li>bridge网络：容器默认使用的网络类型，这是桥接网络，也是应用最广泛的网络类型<br>就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。</li><li>host网络： 当容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的：</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dp完全背包.md</title>
      <link href="/2025/10/19/dp%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>/2025/10/19/dp%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<ul><li>看代码随想录一直不太理解这两句话</li></ul><blockquote><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。<br>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p></blockquote><p>为什么是这样？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求组合数</span></span><br><span class="line"><span class="comment">// 外层循环：遍历物品（颜料）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">    <span class="comment">// 内层循环：遍历背包容量（货架格子）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> item; j &lt;= capacity; j++) &#123;</span><br><span class="line">        dp[j] += dp[j - item];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一轮 (拿出红色颜料)：你拿着红色颜料，从头到尾把货架上所有能刷的地方都刷一遍，更新一遍货架的状态。刷完后，你把红色颜料放回去，并且再也不碰它了。</p><p>第二轮 (拿出蓝色颜料)：你拿着蓝色颜料，在当前已经有了红色的货架的基础上，再把所有能刷的地方刷一遍。因为你固定了物品的使用顺序。你总是先用完所有可能的红色，再用蓝色，再用绿色。所以，你最终得到的方案里，颜色出现的顺序必然是 (红, 蓝, 绿)，你永远不会得到 (蓝, 红, 绿) 这样的方案。因为它忽略了物品的排列顺序，所以它是在计算组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求排列数</span></span><br><span class="line"><span class="comment">// 外层循环：遍历背包容量（货架格子）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">    <span class="comment">// 内层循环：遍历物品（颜料）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= item) &#123;</span><br><span class="line">            dp[i] += dp[i - item];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这相当于你一个格子一个格子地去填。</p><p>第一轮 (填满容量为1的格子)：你问，要填满容量为1的格子，可以用什么颜料？你把所有可用的颜料（红、蓝、绿…）都试一遍，看看谁能填进去。</p><p>第二轮 (填满容量为2的格子)：你问，要填满容量为2的格子，可以怎么做？你可以拿出任何一种颜料，比如红色，然后去看容量为2-红色重量的格子之前是怎么被填满的，把那些方案拿过来，最后涂上红色。你也可以拿出蓝色，再去看…</p><p>…</p><p>为什么这样是求排列？ 因为它在计算每个容量 i 的方案数时，都允许放入任何一个物品。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring快速入门1</title>
      <link href="/2025/10/06/spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2025/10/06/spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>今天搓了一个简单的博客后端，然后之后准备学spring，今天借助gemini和博客简单了解一下spring里面的概念</p><hr><h2 id="优秀的设计都致力于一件事，解耦"><strong>优秀的设计都致力于一件事，解耦</strong></h2><h3 id="开闭原则（OCP-Open-Closed-principle）">开闭原则（OCP  Open/Closed principle）</h3><ul><li>软件实体应该对扩展开放，对修改关闭，简单来讲就是不改变已有的稳定代码，添加新功能</li></ul><h3 id="依赖倒置原则（DIP-dependence-inversion-principle）">依赖倒置原则（DIP dependence inversion principle）</h3><ul><li>高层模块不应该依赖低层模块，两者都应该依赖于抽象（接口）。简单说就是：要面向接口编程，不要面向具体实现编程,想象一下电脑，电脑（高层模块）不关心你插进来的是U盘、鼠标还是键盘（低层模块/具体实现）。只要它们都符合USB接口规范，就能正常工作。</li></ul><h2 id="spring的8个模块">spring的8个模块</h2><ul><li>spring Core:核心容器，提供了Ioc和DI，负责管理spring中的bean</li><li>spring Context：在core的基础上增加更多的功能</li><li>spring ADP：面向切面编程</li><li>spring DAO：数据访问对象</li><li>spring ORM：对象关系映射</li><li>spring Web MVC</li><li>spring WebFlux</li><li>spring Web</li></ul><h3 id="Ioc-控制反转">Ioc 控制反转</h3><ul><li>核心思想：将创建和管理对象的控制权交给了spring容器</li></ul><h3 id="DI-依赖注入">DI 依赖注入</h3><p>依赖注入是实现控制反转的具体行动。<br>场景: 一个 Driver (司机) 类需要一辆 Car (车) 才能工作。<br>传统方式 (没有DI)<br>Driver 类需要自己主动去创建它所依赖的 Car 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="comment">// 司机自己负责 new 一辆车，产生了紧密耦合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题: 这里的 Driver 和 Car 被紧紧地绑定在了一起。如果想让这个司机开卡车，就必须修改 Driver 类的内部代码，这违反了开闭原则。<br>Spring的方式 (使用DI)<br>Driver 类不再自己创建 Car，它只是声明“我需要一辆车”。具体的车由外部的 Spring容器 创建，并通过某种方式**“注入”**给 Driver。</p><p>最常见的注入方式是构造函数注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="comment">// 司机不再自己new车，而是声明一个依赖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数，等待外部把一辆车“注入”进来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(Car injectedCar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.car = injectedCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势: Driver 类现在只依赖于 Car 这个抽象，而不关心具体的车是如何创建的。Spring容器负责创建 Car 对象，并把它“注入”到 Driver 中。这样，如果想换成卡车，只需修改Spring的配置，Driver 类的代码无需任何改动，完美实现了解耦。</p><h3 id="AOP-面向切面编程">AOP 面向切面编程</h3><ul><li>核心思想：将横切关注点从业务中分离出来</li><li>想象一下你要给一栋大楼里的很多房间（业务方法）都安装监控摄像头（通用功能，如日志）。<br>没有AOP: 你需要一个房间一个房间地进去，在墙上打洞，安装摄像头。如果房间很多，会非常麻烦。<br>使用AOP: 你设计了一套“中央监控系统”（切面 Aspect）。你只需要定义好“在哪些类型的房间门口安装”（切点 Pointcut）和“具体安装什么”（通知 Advice），系统就会自动完成所有安装工作。这使得你的房间本身保持干净，只关注自己的核心功能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（三）</title>
      <link href="/2025/10/05/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2025/10/05/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="聚合函数">聚合函数</h3><ul><li>对一组值进行计算，返回单个值，将多行数据压缩成一个统计结果</li></ul><h4 id="常用函数">常用函数</h4><ul><li><code>COUNT(*)</code>:统计行数</li><li><code>SUM(colum)</code></li><li><code>AVG(column)</code>：计算平均值</li><li><code>MAX(column)</code></li><li><code>MIN(column)</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算总员工数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算公司月薪总支出</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h3 id="GROUP-BY子句">GROUP BY子句</h3><p>用于将数据按一列或多列进行分组</p><blockquote><p>在SELECT语句中出现的列，并且没被聚合函数包裹都必须出现在GROUP BY子句中</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    grouping_column,</span><br><span class="line">    aggregate_function(column_to_aggregate)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    grouping_column;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="窗口函数">窗口函数</h3><p>不改变原始行数，在每一行后面添加聚合计算结果</p><p><code>GROUP BY</code>是进行分组压缩，输出组的结果<br>窗口函数是新添加一列计算结果</p><h4 id="OVER子句">OVER子句</h4><p>所有的窗口函数都是用OVER子句定义计算的窗口<br><code>OVER()</code>:窗口包含表中的所有行<br><code>OVER(PARTITION BY)</code>:将窗口内部按列分区<br><code>OVER(ORDER BY)</code>:定义窗口内的排序规则</p><h4 id="常用的窗口函数">常用的窗口函数</h4><p>聚合类: <code>AVG()</code>, <code>SUM()</code>, <code>COUNT()</code> 等聚合函数都可以用作窗口函数。</p><p>排名类:<br><code>RANK()</code>: 标准排名，并列时会跳过后续名次 (e.g., 1, 2, 2, 4)。</p><p><code>DENSE_RANK()</code>: 紧凑排名，并列时不会跳过后续名次 (e.g., 1, 2, 2, 3)。<br>计算每个员工在其部门内的薪水排名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    department,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="comment">-- 先按部门分区，再在部门内按薪水降序排列，然后计算排名</span></span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> salary_rank,</span><br><span class="line">    <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> dense_salary_rank</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees;</span><br></pre></td></tr></table></figure><h3 id="DAO模式">DAO模式</h3><p>数据通常存储在数据库里（MySQL、PostgreSQL、Oracle…），但业务逻辑代码（比如计算订单总价、校验用户权限）并不应该直接和数据库的 SQL 语句耦合。<br>如果业务逻辑层直接写一堆 Connection、Statement、ResultSet，会有几个问题：</p><ul><li><p>耦合度高：业务逻辑和数据库代码混在一起，难以维护。</p></li><li><p>可移植性差：换数据库（MySQL → Oracle）就得改很多地方。</p></li><li><p>测试困难：想单独测试业务逻辑很难，因为总是依赖真实数据库。<br>java中通常分为以下几层</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Controller (界面/接口层)</span><br><span class="line">    ↓</span><br><span class="line">Service (业务逻辑层)</span><br><span class="line">    ↓</span><br><span class="line">DAO (数据访问层)</span><br><span class="line">    ↓</span><br><span class="line">Database (数据库)</span><br></pre></td></tr></table></figure><p>DAO 一般包含以下部分：</p><ul><li><p>DAO 接口：定义数据访问的操作</p></li><li><p>DAO 实现类：实现具体的 SQL 查询、增删改查逻辑</p></li><li><p>实体类 (Entity/Model)：对应数据库表的一条记录</p></li></ul><p>代码流程分为以下几步<br>1.定义实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定义DAO接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(Connection connection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id=?&quot;</span>);</span><br><span class="line">            stmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                u.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                u.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                u.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在Service层中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DAO 就是抽象数据访问的中介层，它的思想是：<br>把数据库操作封装成一个独立模块（接口 + 实现类）。<br>上层（Service/Controller）只用方法，不关心底层 SQL 细节。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（二）</title>
      <link href="/2025/10/04/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/10/04/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="性能优化-索引">性能优化-索引</h2><ul><li>索引可以提升数据库查询性能</li><li>索引是预先创建的一种有序的数据结构</li></ul><h3 id="创建索引">创建索引</h3><p><code>CREATE INDEX index_name ON table_name (column_name);</code></p><h3 id="验证索引是否生效">验证索引是否生效</h3><p><code>EXPLAIN SELECT * FROM table_name WHERE indexed_column = 'some_value';</code></p><ul><li>Seq Scan表示使用全表扫描没用索引</li><li>Index Scan表示成功使用索引</li><li></li></ul><h3 id="索引的好处说完了，代价呢？">索引的好处说完了，代价呢？</h3><ol><li>空间成本：会占用额外的硬盘空间</li><li>维护成本：虽然增加了查询<code>SELECT</code>的速度,但是当数据库要<code>INSERT,UPDATE,DELETE</code>等操作时，还要额外操作索引，降低写操作的速度</li></ol><h3 id="使用原则">使用原则</h3><ul><li>给谁用<ul><li>出现在<code>WHERE</code>子句的列</li><li>使用<code>JOIN</code>d的列</li><li>使用<code>ORDER BY</code>的列</li></ul></li><li>谁慎用<ul><li>写的操作比较多的列</li><li>值的重复度比较高的列（比如值是性别）</li></ul></li></ul><h3 id="索引失效">索引失效</h3><p>通配符在前面的时候，索引会失效<br><code>WHERE name LIKE '张%'; </code>– 能使用索引 (从目录的’Z’部分开始找)。</p><p><code>WHERE name LIKE '%三'; </code>– 无法使用索引 (不知道从哪个字母开始找)，退化为全表扫描</p><blockquote><p>为什么有时候创建索引了但是没有使用?</p></blockquote><blockquote><p>数据库中有一个查询优化器 (Query Optimizer)，它会智能地判断使用索引的成本。<br>核心原因：当数据量非常小时，直接进行全表扫描（一眼看完一张小纸条）比先查索引再找数据（先看目录再翻页）的成本更低，效率更高。因此，优化器会智能地放弃使用索引。只有当数据量大到一定程度，索引的优势才会体现出来。</p></blockquote><h2 id="事务">事务</h2><blockquote><p>将多个操作打包，要么全部成功，要么全部失败的机制</p></blockquote><h3 id="核心命令">核心命令</h3><ul><li><code>BEGIN</code>：开启事务</li><li><code>COMMIT</code>：提交事务，将所有更改保存</li><li><code>ROLLBACK</code>：回滚事务</li><li></li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 2. 执行一系列操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3. 根据情况选择提交或回滚</span></span><br><span class="line"><span class="comment">-- 如果所有操作都成功:</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 如果中途发生错误或想取消:</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><h2 id="JDBC">JDBC</h2><p>依稀记得自己在寒假学java的时候看过这个课，也清楚的记得都忘光了</p><h3 id="什么是JDBC">什么是JDBC</h3><p>JDBC (Java Database Connectivity) 是Java提供的一套标准API，用于连接和操作关系型数据库。它本身是规范，需要由具体的JDBC驱动 (Driver) 来实现。</p><p>类比: JDBC是“普通话”规范，而PostgreSQL的JDBC驱动就是一个能将“普通话”翻译成“PostgreSQL方言”的翻译官。<br>使用maven添加依赖</p><h3 id="建立连接">建立连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://localhost:5432/database_name&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;your_username&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password)) &#123;</span><br><span class="line">    <span class="comment">// 在这里执行数据库操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行查询">执行查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="comment">// ... 在 try-with-resources 块中 ...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name FROM authors;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">     <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行写入">执行写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="comment">// ... 在 try-with-resources 块中 ...</span></span><br><span class="line"><span class="comment">// 使用 &#x27;?&#x27; 作为参数占位符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO authors(name) VALUES(?);&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">    <span class="comment">// 安全地绑定参数</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>, <span class="string">&quot;新作者&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行更新操作</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">    System.out.println(affectedRows + <span class="string">&quot; 行受影响。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为防止SQL注入，必须使用<code>PreparedStatement</code>它允许我们使用 ?作为参数占位符，然后安全地将变量绑定到这些占位符上，而不是像<code>Statement</code>那样手动拼接SQL字符串。这既安全又高效。</p></blockquote><h3 id="在java中管理事务">在java中管理事务</h3><details class="toggle" ><summary class="toggle-button" style="">点击打开</summary><div class="toggle-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://localhost:5432/learning_sql&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;postgres&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       setupDatabase();</span><br><span class="line">       System.out.println(<span class="string">&quot;事务演示&quot;</span>);</span><br><span class="line">       <span class="comment">//成功转账</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n[1.zhangsan 向 lisi 成功转账100.00]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账前账户信息：&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        transMoney(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">100.00</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账后账户余额&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        <span class="comment">//失败转账</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n[2.zhangsan 向 lisi 转账10000.00 失败]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账前账户信息：&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        transMoney(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">10000.00</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账失败后账户余额&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        System.out.println(<span class="string">&quot;演示结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transMoney</span> <span class="params">(String fromAccount, String toAccount, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">            <span class="comment">//关闭自动提交，开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//从转出账户中扣款</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">subtractSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance - ? WHERE name = ? AND balance &gt;= ?;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt1</span> <span class="operator">=</span> conn.prepareStatement(subtractSql)) &#123;</span><br><span class="line">                pstmt1.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">                pstmt1.setString(<span class="number">2</span>, fromAccount);</span><br><span class="line">                pstmt1.setDouble(<span class="number">3</span>, amount);</span><br><span class="line">                <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt1.executeUpdate();</span><br><span class="line">                <span class="keyword">if</span> (affectedRows == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;账户 &quot;</span> + fromAccount + <span class="string">&quot; 余额不足，无法转账。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;从账户 &quot;</span> + fromAccount + <span class="string">&quot; 扣款 &quot;</span> + amount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">addSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance + ? WHERE name = ?;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt2</span> <span class="operator">=</span> conn.prepareStatement(addSql)) &#123;</span><br><span class="line">                pstmt2.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">                pstmt2.setString(<span class="number">2</span>, toAccount);</span><br><span class="line">                pstmt2.executeUpdate();</span><br><span class="line">                System.out.println(<span class="string">&quot;向账户 &quot;</span> + toAccount + <span class="string">&quot; 增加 &quot;</span> + amount);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;转账成功:事务已经提交&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;转账失败:正在回滚事务...&quot;</span>);</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                    System.out.println(<span class="string">&quot;回滚成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;回滚失败&quot;</span>);</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                            conn.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                            ex.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">            <span class="comment">//如果存在就删除旧的表</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;DROP TABLE IF EXISTS accounts;&quot;</span>);</span><br><span class="line">            <span class="comment">//创建新表</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;CREATE TABLE accounts (id SERIAL PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, balance NUMERIC(10,2) NOT NULL);&quot;</span>);</span><br><span class="line">            <span class="comment">//插入初始数据</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;zhangsan&#x27;,1000.00);&quot;</span>);</span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;lisi&#x27;, 500.00);&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库初始化成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;数据库初始化失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectAccounts</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT name, balance FROM accounts ORDER BY name;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;账户： %s, 余额： %.2f\n&quot;</span>, rs.getString(<span class="string">&quot;name&quot;</span>), rs.getDouble(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣HOT100/最长回文子串</title>
      <link href="/2025/10/03/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2025/10/03/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>比较难懂的一道题，我看题解看了半天才想明白<br><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=problem-list-v2&amp;envId=2cktkvj">题目链接</a><br>第一想法是暴力枚举所有的子串，然后判断是否回文，但是太过复杂，判断子串回文要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>,一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的子串，整体的时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，有点慢</p><h3 id="方法一：中心扩展法">方法一：中心扩展法</h3><p>回文串无论长短都是中心对称的，这个方法就是遍历中心，然后不断扩展，唯一注意的就是回文串长度是奇数还是偶数，奇数是以字符为中心，而偶数就是以字符间的缝隙为中心，所以循环遍历的条件是<code>i &lt; 2 * n - 1</code></p><h3 id="方法二：Manacher算法">方法二：Manacher算法</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（一）</title>
      <link href="/2025/10/03/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/10/03/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="postgreSQL学习笔记（一）">postgreSQL学习笔记（一）</h1><hr><p>这学期有一门课程是数据库，外教老师实在一言难尽，只好自学，看了菜鸟教程云里雾里的，然后又不喜欢看视频学习，就让gemini来教我，效果还不错</p><h2 id="基础环境">基础环境</h2><ul><li>创建数据路<br><code>CREATE DATABASE datebase_name;</code></li><li>切换数据库<br><code>\c database_name;</code></li><li>查看表结构<br><code>\d table_name;</code></li><li>创建表<br><code>CREATE TABLE table_name;</code></li></ul><h2 id="数据操作">数据操作</h2><ul><li>插入数据：<code>INSERT INTO;</code></li><li>查询数据：<code>SELECT column1,column2 FROM table_name;</code></li><li>修改数据：<code>UPDATE table_name SET column1 = new_value1 WHERE condition;</code></li><li>删除数据：必须使用where指定删除哪一行，否则会删除整个表</li><li><code>DELETE FROM table_name WHERE condition;</code></li></ul><h2 id="数据查询与表的结构修改">数据查询与表的结构修改</h2><ul><li><p>条件查询<br><code>SEWLECT * FROM table_name WHERE condition1 AND/OR condition2;</code></p></li><li><p>结果排序<br><code>SELECT * FROM table_name ORDER BY column_name ASC/DESC</code><br><code>ASC</code>(默认):升序</p></li><li><p>修改结构<br><code>ALTER TABLE table_name ADD COLUMN column_name data_type</code></p></li><li><p>主键</p><blockquote><p>作用: 唯一标识表中的每一行，其值必须唯一且不能为空 (NOT NULL)。<br>添加方式: ALTER TABLE table_name ADD PRIMARY KEY (column_name);</p></blockquote></li><li><p>自动递增主键 (SERIAL):</p><blockquote><p>作用: PostgreSQL特有的类型，用于创建一个自动递增的整数主键。插入新数据时无需手动指定ID。</p></blockquote><p><code>id SERIAL PRIMARY KEY</code></p><blockquote><p>示例:<br><code>CREATE TABLE students (         id SERIAL PRIMARY KEY,         name VARCHAR(100)     );     -- 插入时无需提供id     INSERT INTO students (name) VALUES ('小明');</code></p></blockquote></li></ul><h2 id="多表联查">多表联查</h2><ul><li><h3 id="外键">外键</h3><pre><code>-作用: 用于将一张表中的列与另一张表的主键关联起来，保证数据的引用完整性。</code></pre><code>CREATE TABLE books (     id SERIAL PRIMARY KEY,     title VARCHAR(255),     author_id INT,     FOREIGN KEY (author_id) REFERENCES     authors(id) );</code></li><li><h3 id="JOIN">JOIN</h3><ul><li>内连接 <code>INNER JOIN</code><br>返回两张表中能通过关联条件匹配上的数据。</li><li>左连接 <code>LEFT JOIN</code><br>作用：返回左面表的所有记录，以及右边表中能匹配上的记录。如果右边表没有匹配项，则用 NULL 填充。</li></ul></li><li><h3 id="子查询">子查询</h3><ul><li>返回单个值的子查询：<ul><li>返回一个值可以使用’='等比较运算符</li><li><code>... WHERE column = (SELECT single_value_column FROM ...);</code></li></ul></li><li>返回列表的子查询：<ul><li>必须用 <code>IN</code> 或 <code>NOT IN</code></li><li><code>... WHERE column IN (SELECT list_column FROM ...);</code></li></ul></li></ul></li><li><h3 id="通用表表达式（CTE）">通用表表达式（CTE）</h3><ul><li>使用<code>WITH</code>关键字定义一个临时的查询结果集，将复杂的查询拆分</li><li><code>WITH cte_name AS ( SELECT ... -- 这里是子查询的逻辑 ) SELECT ... FROM cte_name ...; -- 在主查询中使用这个临时表</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
