<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>dp完全背包.md</title>
      <link href="/2025/10/19/dp%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>/2025/10/19/dp%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<ul><li>看代码随想录一直不太理解这两句话</li></ul><blockquote><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。<br>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p></blockquote><p>为什么是这样？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求组合数</span></span><br><span class="line"><span class="comment">// 外层循环：遍历物品（颜料）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">    <span class="comment">// 内层循环：遍历背包容量（货架格子）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> item; j &lt;= capacity; j++) &#123;</span><br><span class="line">        dp[j] += dp[j - item];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一轮 (拿出红色颜料)：你拿着红色颜料，从头到尾把货架上所有能刷的地方都刷一遍，更新一遍货架的状态。刷完后，你把红色颜料放回去，并且再也不碰它了。</p><p>第二轮 (拿出蓝色颜料)：你拿着蓝色颜料，在当前已经有了红色的货架的基础上，再把所有能刷的地方刷一遍。因为你固定了物品的使用顺序。你总是先用完所有可能的红色，再用蓝色，再用绿色。所以，你最终得到的方案里，颜色出现的顺序必然是 (红, 蓝, 绿)，你永远不会得到 (蓝, 红, 绿) 这样的方案。因为它忽略了物品的排列顺序，所以它是在计算组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求排列数</span></span><br><span class="line"><span class="comment">// 外层循环：遍历背包容量（货架格子）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">    <span class="comment">// 内层循环：遍历物品（颜料）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= item) &#123;</span><br><span class="line">            dp[i] += dp[i - item];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这相当于你一个格子一个格子地去填。</p><p>第一轮 (填满容量为1的格子)：你问，要填满容量为1的格子，可以用什么颜料？你把所有可用的颜料（红、蓝、绿…）都试一遍，看看谁能填进去。</p><p>第二轮 (填满容量为2的格子)：你问，要填满容量为2的格子，可以怎么做？你可以拿出任何一种颜料，比如红色，然后去看容量为2-红色重量的格子之前是怎么被填满的，把那些方案拿过来，最后涂上红色。你也可以拿出蓝色，再去看…</p><p>…</p><p>为什么这样是求排列？ 因为它在计算每个容量 i 的方案数时，都允许放入任何一个物品。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring快速入门1</title>
      <link href="/2025/10/06/spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2025/10/06/spring%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>今天搓了一个简单的博客后端，然后之后准备学spring，今天借助gemini和博客简单了解一下spring里面的概念</p><hr><h2 id="优秀的设计都致力于一件事，解耦"><strong>优秀的设计都致力于一件事，解耦</strong></h2><h3 id="开闭原则（OCP-Open-Closed-principle）">开闭原则（OCP  Open/Closed principle）</h3><ul><li>软件实体应该对扩展开放，对修改关闭，简单来讲就是不改变已有的稳定代码，添加新功能</li></ul><h3 id="依赖倒置原则（DIP-dependence-inversion-principle）">依赖倒置原则（DIP dependence inversion principle）</h3><ul><li>高层模块不应该依赖低层模块，两者都应该依赖于抽象（接口）。简单说就是：要面向接口编程，不要面向具体实现编程,想象一下电脑，电脑（高层模块）不关心你插进来的是U盘、鼠标还是键盘（低层模块/具体实现）。只要它们都符合USB接口规范，就能正常工作。</li></ul><h2 id="spring的8个模块">spring的8个模块</h2><ul><li>spring Core:核心容器，提供了Ioc和DI，负责管理spring中的bean</li><li>spring Context：在core的基础上增加更多的功能</li><li>spring ADP：面向切面编程</li><li>spring DAO：数据访问对象</li><li>spring ORM：对象关系映射</li><li>spring Web MVC</li><li>spring WebFlux</li><li>spring Web</li></ul><h3 id="Ioc-控制反转">Ioc 控制反转</h3><ul><li>核心思想：将创建和管理对象的控制权交给了spring容器</li></ul><h3 id="DI-依赖注入">DI 依赖注入</h3><p>依赖注入是实现控制反转的具体行动。<br>场景: 一个 Driver (司机) 类需要一辆 Car (车) 才能工作。<br>传统方式 (没有DI)<br>Driver 类需要自己主动去创建它所依赖的 Car 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="comment">// 司机自己负责 new 一辆车，产生了紧密耦合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题: 这里的 Driver 和 Car 被紧紧地绑定在了一起。如果想让这个司机开卡车，就必须修改 Driver 类的内部代码，这违反了开闭原则。<br>Spring的方式 (使用DI)<br>Driver 类不再自己创建 Car，它只是声明“我需要一辆车”。具体的车由外部的 Spring容器 创建，并通过某种方式**“注入”**给 Driver。</p><p>最常见的注入方式是构造函数注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="comment">// 司机不再自己new车，而是声明一个依赖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数，等待外部把一辆车“注入”进来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(Car injectedCar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.car = injectedCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势: Driver 类现在只依赖于 Car 这个抽象，而不关心具体的车是如何创建的。Spring容器负责创建 Car 对象，并把它“注入”到 Driver 中。这样，如果想换成卡车，只需修改Spring的配置，Driver 类的代码无需任何改动，完美实现了解耦。</p><h3 id="AOP-面向切面编程">AOP 面向切面编程</h3><ul><li>核心思想：将横切关注点从业务中分离出来</li><li>想象一下你要给一栋大楼里的很多房间（业务方法）都安装监控摄像头（通用功能，如日志）。<br>没有AOP: 你需要一个房间一个房间地进去，在墙上打洞，安装摄像头。如果房间很多，会非常麻烦。<br>使用AOP: 你设计了一套“中央监控系统”（切面 Aspect）。你只需要定义好“在哪些类型的房间门口安装”（切点 Pointcut）和“具体安装什么”（通知 Advice），系统就会自动完成所有安装工作。这使得你的房间本身保持干净，只关注自己的核心功能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（三）</title>
      <link href="/2025/10/05/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2025/10/05/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="聚合函数">聚合函数</h3><ul><li>对一组值进行计算，返回单个值，将多行数据压缩成一个统计结果</li></ul><h4 id="常用函数">常用函数</h4><ul><li><code>COUNT(*)</code>:统计行数</li><li><code>SUM(colum)</code></li><li><code>AVG(column)</code>：计算平均值</li><li><code>MAX(column)</code></li><li><code>MIN(column)</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算总员工数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算公司月薪总支出</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h3 id="GROUP-BY子句">GROUP BY子句</h3><p>用于将数据按一列或多列进行分组</p><blockquote><p>在SELECT语句中出现的列，并且没被聚合函数包裹都必须出现在GROUP BY子句中</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    grouping_column,</span><br><span class="line">    aggregate_function(column_to_aggregate)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    grouping_column;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="窗口函数">窗口函数</h3><p>不改变原始行数，在每一行后面添加聚合计算结果</p><p><code>GROUP BY</code>是进行分组压缩，输出组的结果<br>窗口函数是新添加一列计算结果</p><h4 id="OVER子句">OVER子句</h4><p>所有的窗口函数都是用OVER子句定义计算的窗口<br><code>OVER()</code>:窗口包含表中的所有行<br><code>OVER(PARTITION BY)</code>:将窗口内部按列分区<br><code>OVER(ORDER BY)</code>:定义窗口内的排序规则</p><h4 id="常用的窗口函数">常用的窗口函数</h4><p>聚合类: <code>AVG()</code>, <code>SUM()</code>, <code>COUNT()</code> 等聚合函数都可以用作窗口函数。</p><p>排名类:<br><code>RANK()</code>: 标准排名，并列时会跳过后续名次 (e.g., 1, 2, 2, 4)。</p><p><code>DENSE_RANK()</code>: 紧凑排名，并列时不会跳过后续名次 (e.g., 1, 2, 2, 3)。<br>计算每个员工在其部门内的薪水排名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    department,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="comment">-- 先按部门分区，再在部门内按薪水降序排列，然后计算排名</span></span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> salary_rank,</span><br><span class="line">    <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> dense_salary_rank</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees;</span><br></pre></td></tr></table></figure><h3 id="DAO模式">DAO模式</h3><p>数据通常存储在数据库里（MySQL、PostgreSQL、Oracle…），但业务逻辑代码（比如计算订单总价、校验用户权限）并不应该直接和数据库的 SQL 语句耦合。<br>如果业务逻辑层直接写一堆 Connection、Statement、ResultSet，会有几个问题：</p><ul><li><p>耦合度高：业务逻辑和数据库代码混在一起，难以维护。</p></li><li><p>可移植性差：换数据库（MySQL → Oracle）就得改很多地方。</p></li><li><p>测试困难：想单独测试业务逻辑很难，因为总是依赖真实数据库。<br>java中通常分为以下几层</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Controller (界面/接口层)</span><br><span class="line">    ↓</span><br><span class="line">Service (业务逻辑层)</span><br><span class="line">    ↓</span><br><span class="line">DAO (数据访问层)</span><br><span class="line">    ↓</span><br><span class="line">Database (数据库)</span><br></pre></td></tr></table></figure><p>DAO 一般包含以下部分：</p><ul><li><p>DAO 接口：定义数据访问的操作</p></li><li><p>DAO 实现类：实现具体的 SQL 查询、增删改查逻辑</p></li><li><p>实体类 (Entity/Model)：对应数据库表的一条记录</p></li></ul><p>代码流程分为以下几步<br>1.定义实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定义DAO接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(Connection connection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id=?&quot;</span>);</span><br><span class="line">            stmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                u.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                u.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                u.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在Service层中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DAO 就是抽象数据访问的中介层，它的思想是：<br>把数据库操作封装成一个独立模块（接口 + 实现类）。<br>上层（Service/Controller）只用方法，不关心底层 SQL 细节。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（二）</title>
      <link href="/2025/10/04/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/10/04/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="性能优化-索引">性能优化-索引</h2><ul><li>索引可以提升数据库查询性能</li><li>索引是预先创建的一种有序的数据结构</li></ul><h3 id="创建索引">创建索引</h3><p><code>CREATE INDEX index_name ON table_name (column_name);</code></p><h3 id="验证索引是否生效">验证索引是否生效</h3><p><code>EXPLAIN SELECT * FROM table_name WHERE indexed_column = 'some_value';</code></p><ul><li>Seq Scan表示使用全表扫描没用索引</li><li>Index Scan表示成功使用索引</li><li></li></ul><h3 id="索引的好处说完了，代价呢？">索引的好处说完了，代价呢？</h3><ol><li>空间成本：会占用额外的硬盘空间</li><li>维护成本：虽然增加了查询<code>SELECT</code>的速度,但是当数据库要<code>INSERT,UPDATE,DELETE</code>等操作时，还要额外操作索引，降低写操作的速度</li></ol><h3 id="使用原则">使用原则</h3><ul><li>给谁用<ul><li>出现在<code>WHERE</code>子句的列</li><li>使用<code>JOIN</code>d的列</li><li>使用<code>ORDER BY</code>的列</li></ul></li><li>谁慎用<ul><li>写的操作比较多的列</li><li>值的重复度比较高的列（比如值是性别）</li></ul></li></ul><h3 id="索引失效">索引失效</h3><p>通配符在前面的时候，索引会失效<br><code>WHERE name LIKE '张%'; </code>– 能使用索引 (从目录的’Z’部分开始找)。</p><p><code>WHERE name LIKE '%三'; </code>– 无法使用索引 (不知道从哪个字母开始找)，退化为全表扫描</p><blockquote><p>为什么有时候创建索引了但是没有使用?</p></blockquote><blockquote><p>数据库中有一个查询优化器 (Query Optimizer)，它会智能地判断使用索引的成本。<br>核心原因：当数据量非常小时，直接进行全表扫描（一眼看完一张小纸条）比先查索引再找数据（先看目录再翻页）的成本更低，效率更高。因此，优化器会智能地放弃使用索引。只有当数据量大到一定程度，索引的优势才会体现出来。</p></blockquote><h2 id="事务">事务</h2><blockquote><p>将多个操作打包，要么全部成功，要么全部失败的机制</p></blockquote><h3 id="核心命令">核心命令</h3><ul><li><code>BEGIN</code>：开启事务</li><li><code>COMMIT</code>：提交事务，将所有更改保存</li><li><code>ROLLBACK</code>：回滚事务</li><li></li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 2. 执行一系列操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3. 根据情况选择提交或回滚</span></span><br><span class="line"><span class="comment">-- 如果所有操作都成功:</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 如果中途发生错误或想取消:</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><h2 id="JDBC">JDBC</h2><p>依稀记得自己在寒假学java的时候看过这个课，也清楚的记得都忘光了</p><h3 id="什么是JDBC">什么是JDBC</h3><p>JDBC (Java Database Connectivity) 是Java提供的一套标准API，用于连接和操作关系型数据库。它本身是规范，需要由具体的JDBC驱动 (Driver) 来实现。</p><p>类比: JDBC是“普通话”规范，而PostgreSQL的JDBC驱动就是一个能将“普通话”翻译成“PostgreSQL方言”的翻译官。<br>使用maven添加依赖</p><h3 id="建立连接">建立连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://localhost:5432/database_name&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;your_username&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password)) &#123;</span><br><span class="line">    <span class="comment">// 在这里执行数据库操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行查询">执行查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="comment">// ... 在 try-with-resources 块中 ...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name FROM authors;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">     <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行写入">执行写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="comment">// ... 在 try-with-resources 块中 ...</span></span><br><span class="line"><span class="comment">// 使用 &#x27;?&#x27; 作为参数占位符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO authors(name) VALUES(?);&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">    <span class="comment">// 安全地绑定参数</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>, <span class="string">&quot;新作者&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行更新操作</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">    System.out.println(affectedRows + <span class="string">&quot; 行受影响。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为防止SQL注入，必须使用<code>PreparedStatement</code>它允许我们使用 ?作为参数占位符，然后安全地将变量绑定到这些占位符上，而不是像<code>Statement</code>那样手动拼接SQL字符串。这既安全又高效。</p></blockquote><h3 id="在java中管理事务">在java中管理事务</h3><details class="toggle" ><summary class="toggle-button" style="">点击打开</summary><div class="toggle-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://localhost:5432/learning_sql&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;postgres&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       setupDatabase();</span><br><span class="line">       System.out.println(<span class="string">&quot;事务演示&quot;</span>);</span><br><span class="line">       <span class="comment">//成功转账</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n[1.zhangsan 向 lisi 成功转账100.00]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账前账户信息：&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        transMoney(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">100.00</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账后账户余额&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        <span class="comment">//失败转账</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n[2.zhangsan 向 lisi 转账10000.00 失败]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账前账户信息：&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        transMoney(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">10000.00</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账失败后账户余额&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        System.out.println(<span class="string">&quot;演示结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transMoney</span> <span class="params">(String fromAccount, String toAccount, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">            <span class="comment">//关闭自动提交，开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//从转出账户中扣款</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">subtractSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance - ? WHERE name = ? AND balance &gt;= ?;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt1</span> <span class="operator">=</span> conn.prepareStatement(subtractSql)) &#123;</span><br><span class="line">                pstmt1.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">                pstmt1.setString(<span class="number">2</span>, fromAccount);</span><br><span class="line">                pstmt1.setDouble(<span class="number">3</span>, amount);</span><br><span class="line">                <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt1.executeUpdate();</span><br><span class="line">                <span class="keyword">if</span> (affectedRows == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;账户 &quot;</span> + fromAccount + <span class="string">&quot; 余额不足，无法转账。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;从账户 &quot;</span> + fromAccount + <span class="string">&quot; 扣款 &quot;</span> + amount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">addSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance + ? WHERE name = ?;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt2</span> <span class="operator">=</span> conn.prepareStatement(addSql)) &#123;</span><br><span class="line">                pstmt2.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">                pstmt2.setString(<span class="number">2</span>, toAccount);</span><br><span class="line">                pstmt2.executeUpdate();</span><br><span class="line">                System.out.println(<span class="string">&quot;向账户 &quot;</span> + toAccount + <span class="string">&quot; 增加 &quot;</span> + amount);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;转账成功:事务已经提交&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;转账失败:正在回滚事务...&quot;</span>);</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                    System.out.println(<span class="string">&quot;回滚成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;回滚失败&quot;</span>);</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                            conn.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                            ex.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">            <span class="comment">//如果存在就删除旧的表</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;DROP TABLE IF EXISTS accounts;&quot;</span>);</span><br><span class="line">            <span class="comment">//创建新表</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;CREATE TABLE accounts (id SERIAL PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, balance NUMERIC(10,2) NOT NULL);&quot;</span>);</span><br><span class="line">            <span class="comment">//插入初始数据</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;zhangsan&#x27;,1000.00);&quot;</span>);</span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;lisi&#x27;, 500.00);&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库初始化成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;数据库初始化失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectAccounts</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT name, balance FROM accounts ORDER BY name;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;账户： %s, 余额： %.2f\n&quot;</span>, rs.getString(<span class="string">&quot;name&quot;</span>), rs.getDouble(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣HOT100/最长回文子串</title>
      <link href="/2025/10/03/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2025/10/03/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>比较难懂的一道题，我看题解看了半天才想明白<br><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=problem-list-v2&amp;envId=2cktkvj">题目链接</a><br>第一想法是暴力枚举所有的子串，然后判断是否回文，但是太过复杂，判断子串回文要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>,一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的子串，整体的时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，有点慢</p><h3 id="方法一：中心扩展法">方法一：中心扩展法</h3><p>回文串无论长短都是中心对称的，这个方法就是遍历中心，然后不断扩展，唯一注意的就是回文串长度是奇数还是偶数，奇数是以字符为中心，而偶数就是以字符间的缝隙为中心，所以循环遍历的条件是<code>i &lt; 2 * n - 1</code></p><h3 id="方法二：Manacher算法">方法二：Manacher算法</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（一）</title>
      <link href="/2025/10/03/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/10/03/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="postgreSQL学习笔记（一）">postgreSQL学习笔记（一）</h1><hr><p>这学期有一门课程是数据库，外教老师实在一言难尽，只好自学，看了菜鸟教程云里雾里的，然后又不喜欢看视频学习，就让gemini来教我，效果还不错</p><h2 id="基础环境">基础环境</h2><ul><li>创建数据路<br><code>CREATE DATABASE datebase_name;</code></li><li>切换数据库<br><code>\c database_name;</code></li><li>查看表结构<br><code>\d table_name;</code></li><li>创建表<br><code>CREATE TABLE table_name;</code></li></ul><h2 id="数据操作">数据操作</h2><ul><li>插入数据：<code>INSERT INTO;</code></li><li>查询数据：<code>SELECT column1,column2 FROM table_name;</code></li><li>修改数据：<code>UPDATE table_name SET column1 = new_value1 WHERE condition;</code></li><li>删除数据：必须使用where指定删除哪一行，否则会删除整个表</li><li><code>DELETE FROM table_name WHERE condition;</code></li></ul><h2 id="数据查询与表的结构修改">数据查询与表的结构修改</h2><ul><li><p>条件查询<br><code>SEWLECT * FROM table_name WHERE condition1 AND/OR condition2;</code></p></li><li><p>结果排序<br><code>SELECT * FROM table_name ORDER BY column_name ASC/DESC</code><br><code>ASC</code>(默认):升序</p></li><li><p>修改结构<br><code>ALTER TABLE table_name ADD COLUMN column_name data_type</code></p></li><li><p>主键</p><blockquote><p>作用: 唯一标识表中的每一行，其值必须唯一且不能为空 (NOT NULL)。<br>添加方式: ALTER TABLE table_name ADD PRIMARY KEY (column_name);</p></blockquote></li><li><p>自动递增主键 (SERIAL):</p><blockquote><p>作用: PostgreSQL特有的类型，用于创建一个自动递增的整数主键。插入新数据时无需手动指定ID。</p></blockquote><p><code>id SERIAL PRIMARY KEY</code></p><blockquote><p>示例:<br><code>CREATE TABLE students (         id SERIAL PRIMARY KEY,         name VARCHAR(100)     );     -- 插入时无需提供id     INSERT INTO students (name) VALUES ('小明');</code></p></blockquote></li></ul><h2 id="多表联查">多表联查</h2><ul><li><h3 id="外键">外键</h3><pre><code>-作用: 用于将一张表中的列与另一张表的主键关联起来，保证数据的引用完整性。</code></pre><code>CREATE TABLE books (     id SERIAL PRIMARY KEY,     title VARCHAR(255),     author_id INT,     FOREIGN KEY (author_id) REFERENCES     authors(id) );</code></li><li><h3 id="JOIN">JOIN</h3><ul><li>内连接 <code>INNER JOIN</code><br>返回两张表中能通过关联条件匹配上的数据。</li><li>左连接 <code>LEFT JOIN</code><br>作用：返回左面表的所有记录，以及右边表中能匹配上的记录。如果右边表没有匹配项，则用 NULL 填充。</li></ul></li><li><h3 id="子查询">子查询</h3><ul><li>返回单个值的子查询：<ul><li>返回一个值可以使用’='等比较运算符</li><li><code>... WHERE column = (SELECT single_value_column FROM ...);</code></li></ul></li><li>返回列表的子查询：<ul><li>必须用 <code>IN</code> 或 <code>NOT IN</code></li><li><code>... WHERE column IN (SELECT list_column FROM ...);</code></li></ul></li></ul></li><li><h3 id="通用表表达式（CTE）">通用表表达式（CTE）</h3><ul><li>使用<code>WITH</code>关键字定义一个临时的查询结果集，将复杂的查询拆分</li><li><code>WITH cte_name AS ( SELECT ... -- 这里是子查询的逻辑 ) SELECT ... FROM cte_name ...; -- 在主查询中使用这个临时表</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
