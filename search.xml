<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql</title>
      <link href="/2026/02/01/Mysql/"/>
      <url>/2026/02/01/Mysql/</url>
      
        <content type="html"><![CDATA[<p>我是根据黑马的视频学习的，之前零零散散的学习过mysql， 会写基础的sql，所以基础部分掠过，直接看得<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.788.player.switch&amp;vd_source=e5201fb199b25d68c383fec45484b73b&amp;p=68">进阶篇</a></p><h3 id="索引">索引</h3><h4 id="Hash索引">Hash索引</h4><h5 id="特点">特点</h5><ul><li>只能用于对等比较(=, in), 不支持范围查询(between, &gt;, &lt;)</li><li>无法利用索引完成排序操作</li><li>查询通常一次检索就可以，效率高，通常高于比B+tree索引</li></ul><h5 id="存储引擎支持：">存储引擎支持：</h5><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h5 id="为什么innoDB使用B-tree">为什么innoDB使用B+tree</h5><table><thead><tr><th><strong>特性</strong></th><th><strong>哈希表 (Hash)</strong></th><th><strong>二叉平衡树 (AVL/红黑树)</strong></th><th><strong>B 树</strong></th><th><strong>B+ 树 (InnoDB选择)</strong></th></tr></thead><tbody><tr><td><strong>等值查询</strong></td><td>极快</td><td>快</td><td>快</td><td>快</td></tr><tr><td><strong>范围查询</strong></td><td>不支持</td><td>较慢 (需回溯)</td><td>一般 (需跨层)</td><td><strong>极快 (链表遍历)</strong></td></tr><tr><td><strong>磁盘 I/O</strong></td><td>较多</td><td>很多 (树太高)</td><td>较少</td><td><strong>极少 (树最矮)</strong></td></tr><tr><td><strong>排序支持</strong></td><td>不支持</td><td>支持</td><td>支持</td><td><strong>天然支持且高效</strong></td></tr></tbody></table><ul><li>相较于二叉树，层级更少，搜索效率高</li><li>相较于B树，B树每个节点既存key又存数据，导致每个节点容纳的数据更少，树会更高</li><li>相较于hash，B+支持范围匹配及查询</li></ul><h4 id="语法">语法</h4><h5 id="创建">创建</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建普通索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建联合索引（多列索引）</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (col1, col2, col3);</span><br></pre></td></tr></table></figure><h5 id="查看">查看</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure><h5 id="删除">删除</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> table_name;</span><br></pre></td></tr></table></figure><h4 id="sql性能分析">sql性能分析</h4><h5 id="查看sql执行频次">查看sql执行频次</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前所有次数统计</span></span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_____&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_select&#x27;</span>; <span class="comment">-- 查询次数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="慢查询日志">慢查询日志</h5><p>记录所有执行时间超过阈值的sql，默认情况下，mysql不开启慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看是否开启</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br><span class="line"><span class="comment">-- 临时开启（重启后失效</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 设置阈值，单位秒</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h5 id="explain">explain</h5><ul><li>使用<br>只需要在sql前加上explain就行</li></ul><p>各个字段含义</p><ol><li>id<br>输出的id字段代表执行顺序<ul><li>id相同：执行顺序从上到下</li><li>id不同：id大的，执行优先级更高</li></ul></li><li>type<br>表示连接类型，性能由好到差依次是NULL,system, const, eq_ref, ref, range index, all</li></ol><h4 id="索引的使用">索引的使用</h4><h5 id="最左前缀法则">最左前缀法则</h5><p>如果索引关联了多列(联合索引)，则遵循最左前缀法则，也就是说，在联合索引中，查询必须从索引的最左列开始，不能跳过索引</p><p>假设在一个user表上建立一个联合索引 <code>index(a,b,c)</code><br>三种使用场景</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全值匹配</span></span><br><span class="line"><span class="comment">-- 完全符合最做前缀法则，sql的编写顺序不影响（比如先写 `b=2` 再写 `a=1`）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部分匹配</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 违背规则 索引部分或全部失效</span></span><br><span class="line"><span class="comment">-- 完全失效</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 部分失效</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果联合索引中某个列使用了<strong>范围查询</strong>（<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like 'xxx%'</code>），那么该列右侧的索引列将失效。可以使用&gt;= &lt;= 来规避</p><p><em>为什么范围查询右侧会失效</em>，使用&gt;=, &lt;=可以规避</p><ul><li>在<code>select * from user where a = 1 and b &gt; 10 and c = 3</code>中，B+树是按a排序的，如果a相等按b，然后再按c，<code>a = 1</code>：mysql很快就会定位到对应的数据块，<code>b &gt; 10</code>：在a = 1 范围内，b是有序的，可以很快找到符合条件的b，<code>c = 3</code>: b &gt; 10中， b可能等于11, 12, 13…… ，在b = 11范围内，c是有序的，但是在整个b &gt; 10的结果集里，c整体是无序的，所以B+树无法按索引跳跃查找，只能扫描</li><li>其实，<code>&gt;=</code> 并没有从底层算法上彻底改变 B+ 树的逻辑，但在某些情况下，它能让 <strong>等值的那部分数据</strong> 继续利用索引。</li></ul><h4 id="索引失效">索引失效</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。<br>or是一个并集操作， 假设执行<code>select * from where id = 10 and name = zhangsan;</code>,id是主键使用主键索引，但是name没有索引，依然要进行全表扫描</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="SQL提示">SQL提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="聚集索引">聚集索引</h4><p>B+树存储，叶子节点存储的完整的行记录，每个表只能有一个聚集索引<br><strong>选取规则</strong>：</p><ul><li>如果有主键，主键就是聚集索引</li><li>没有主键，选择第一个不为NULL的唯一索引</li><li>都没有，innoDB生成一个隐式的row_id作为聚集索引</li></ul><h4 id="二级索引">二级索引</h4><p>除聚集索引外的其他索引，都是二级索引，也叫辅助索引，椰子节点存储的是该行对应的主键值<br>包含的是 索引对应的列以及主键</p><h4 id="回表">回表</h4><ol><li><p><strong>第一步</strong>：SQL 在 <strong>二级索引树</strong> 中找到 <code>name='张三'</code>，并获取到对应的 ID（如 <code>ID=10</code>）。</p></li><li><p><strong>第二步</strong>：由于二级索引没存完整的行数据，MySQL 需要拿着这个 <code>ID=10</code> 回到 <strong>聚集索引树</strong> 中再次查找，以获取完整的行记录。</p></li></ol><p><strong>这个从二级索引回到聚集索引查找数据的过程，就叫“回表”。</strong></p><h4 id="聚集索引-2">聚集索引</h4><p>不是一种实际存在的索引，而是一种查询时的现象：一个索引包含所需要查询的所有字段，它就不需要进行回表，直接从索引中返回数据</p><h5 id="如何判断是否使用了聚集索引">如何判断是否使用了聚集索引</h5><p>查看explain结果的extra列，结果是</p><ul><li>Using index:说明使用了覆盖索引</li><li>Using index condition: 说明使用了索引，但是有可能发生回表</li><li>null/where： 意味着发生了回表</li></ul><h4 id="前缀索引">前缀索引</h4><p>在对一个包含大量字符，文本的列建立索引时，索引会变得很大，而且效率低下，于是产生了前缀索引，只取字段的前一部分字符建立索引</p><h5 id="语法-2">语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_email_10 <span class="keyword">ON</span> <span class="keyword">user</span> (email(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h5 id="确定合适的前缀长度">确定合适的前缀长度</h5><p>先了解一下选择性的概念：它是指不重复的索引值（基数）与表记录总数的比值。比值越高，查询效率越高</p><p>计算公式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看全列的选择性</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- 查看不同长度前缀的选择性</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>如果前缀太短，容易重复，会增加回表的次数，太长又失去节省空间的意义</p><h5 id="前缀索引的缺点">前缀索引的缺点</h5><ul><li>不能成为覆盖索引，因为存储的是字段的前缀，要确定字段的值，一定会去回表查看。所以即使只查看该列，explain的extra也会显示回表</li><li>不适用于排序和分组group，因为前缀索引只代表部分顺序，无法保证完整字段的排序结果</li></ul><h4 id="索引设计原则">索引设计原则</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260131153523816.webp" alt="image.png"></p><h3 id="SQL优化">SQL优化</h3><h4 id="插入数据">插入数据</h4><ol><li>批量插入数据</li><li>手动提交事物</li><li>按主键顺序优化<ul><li><p><strong>减少页分裂：</strong> InnoDB 的数据是存储在 B+ 树的叶子节点上的。顺序插入时，数据会被追加在当前页的末尾，页满后才开辟新页。</p></li><li><p><strong>避免性能骤降：</strong> 如果主键是随机的（如 UUID），为了保持 B+ 树有序，MySQL 必须频繁地在中间位置插入数据，这会导致频繁的<strong>页分裂</strong>和记录移动，产生大量的随机 I/O 和索引碎片。</p></li></ul></li></ol><h5 id="大批量插入数据">大批量插入数据</h5><p>如果数据量特别大，使用insert的效率会比较低，应该使用mysql自带的load<br>开启操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 <span class="comment">--local-infile（这一行在bash/cmd界面输入）  </span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p  </span></span><br><span class="line"># 设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关  </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@local_infile</span>;  </span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中  </span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;tb_user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="主键优化">主键优化</h4><ul><li><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。</p></li><li><p>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p></li></ul><h5 id="主键设计原则：">主键设计原则：</h5><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h4 id="order-by优化">order by优化</h4><ul><li><p><strong>Using index</strong>：<strong>效率最高</strong>。指 MySQL 直接通过索引树的有序性完成排序，不需要额外操作。</p></li><li><p><strong>Using filesort</strong>：<strong>效率较低</strong>。指 MySQL 无法利用索引，必须在内存（sort_buffer）或磁盘中进行排序操作。</p></li></ul><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h4 id="group-by优化">group by优化</h4><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>zap的使用</title>
      <link href="/2026/01/31/zap%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2026/01/31/zap%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀树</title>
      <link href="/2026/01/30/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
      <url>/2026/01/30/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="前缀树">前缀树</h3><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=problem-list-v2&amp;envId=2cktkvj">力扣练习题</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;  </span><br><span class="line">    children [<span class="number">26</span>]*TrieNode  </span><br><span class="line">    isEnd    <span class="type">bool</span>  <span class="comment">//是否有以当前节点为结尾的单词</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;  </span><br><span class="line">    root *TrieNode  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Trie &#123;  </span><br><span class="line">    <span class="keyword">return</span> Trie&#123;root: &amp;TrieNode&#123;&#125;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;  </span><br><span class="line">    move := t.root  </span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;  </span><br><span class="line">       index := ch - <span class="string">&#x27;a&#x27;</span>  </span><br><span class="line">       <span class="keyword">if</span> move.children[index] == <span class="literal">nil</span> &#123;  </span><br><span class="line">          move.children[index] = &amp;TrieNode&#123;&#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       move = move.children[index]  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> search(word <span class="type">string</span>) *TrieNode &#123;  </span><br><span class="line">    move := t.root  </span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;  </span><br><span class="line">       index := ch - <span class="string">&#x27;a&#x27;</span>  </span><br><span class="line">       <span class="keyword">if</span> move.children[index] == <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">       move = move.children[index]  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> move  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;  </span><br><span class="line">    node := t.search(word)  </span><br><span class="line">    <span class="comment">//找到节点不一定就是找到单词，比如之前插入了apple，但是没有插入app，此时就应该返回false</span></span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nil</span> &amp;&amp; node.isEnd  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;  </span><br><span class="line">    node := t.search(prefix)  </span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩前缀树">压缩前缀树</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-网络层</title>
      <link href="/2026/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2026/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="网络层">网络层</h3><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?spm_id_from=333.788.player.switch&amp;vd_source=e5201fb199b25d68c383fec45484b73b&amp;p=44">湖科大计网</a></p><h4 id="分类编址的IPv4地址">分类编址的IPv4地址</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%9B%BE%202026-01-24%2018-05-56.webp" alt=""></p><h5 id="A类地址">A类地址</h5><p>最小网络号为0, 保留不指派<br>第一个可指派的网络号为1, 网络地址为1.0.0.0<br>最大网络号为127, 作为本地环回测试地址，不指派</p><ul><li>最小的本地环回测试地址为127.0.0.1</li><li>最大的本地环回测试地址为127.255.255.254<br>最后一个可指派的网络号为126</li></ul><p>可指派的网络的数量为126， 每个网络中可以分配的IP地址数量为<code>2^24 - 2 = 16777214 </code>(减2是取出全0的网络地址和全1的广播地址）</p><h5 id="B类">B类</h5><p>最小网络号128, 最大网络号191.255<br>可指派网络数为2 ^ (16 - 2) = 16384， 每个网络中可分配的IP地址数量为2 ^ 16 - 2 = 65534</p><h5 id="C类">C类</h5><p>最小网络号192, 最大网络号223.255.255<br>可指派的C类网络数量2 ^（24 - 3), 每个网络中可分配的IP地址数量为2 ^ 8 - 2</p><h4 id="划分子网的IPv4地址">划分子网的IPv4地址</h4><p>为了减少IP的浪费，把一个大的IP地址切分为多个小的子网</p><p>结构变为&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;<br><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%9B%BE%202026-01-25%2015-11-52.webp" alt=""></p><h4 id="无分类编址的IPv4地址">无分类编址的IPv4地址</h4><p>即使有了划分子网，但是还不够彻底，仍然有巨大的浪费</p><p>Classless Inter-Domain Routing (无分类域间路由)CIDR 使用斜线记法，可以在 IP 后面直接写 <code>/n</code>，表示前 <code>n</code> 位是网络前缀</p><h5 id="路由聚合（构造超网）">路由聚合（构造超网）</h5><p>将多个较小的子网和1并成一个较大的网络<br>网络前缀越长，路由越具体，如果路由器查表转发分组的时候发现有多条路由可以选择，则选择网络前缀最长的那个，这样的路由更具体</p><h4 id="IPv4地址的应用规划">IPv4地址的应用规划</h4><p>采用 VLSM (可变长子网掩码)，根据实际的主机数量，按需分配</p><h4 id="IP数据报的发送和转发过程">IP数据报的发送和转发过程</h4><p>主机A给B发送数据，先将自己的IP地址与子网掩码进行<code>与</code>运算，得出自己的网络号。然后将目标IP地址与子网掩码<code>与</code>运算，得到目标地址的网络号，如果相同，说明在同一个子网内，主机A直接发送给B。如果不同，说明不在同一个子网内，主机A将数据发送给默认网关（通常是路由器），路由器拿着目的IP地址与自己路由表里的条目逐条匹配，如果找到，就将数据发送</p><p>匹配算法</p><ul><li><p>用路由表中每一行的<strong>掩码</strong>与<strong>目标 IP (D)</strong> 做 AND 运算。</p></li><li><p>如果结果等于该行的<strong>目的网络地址</strong>，则匹配成功。</p></li><li><p>如果有多行匹配成功，选择<strong>掩码最长</strong>（最精确）的那一行。</p></li><li><p>如果没有一行匹配，丢弃数据报，向源主机报错（ICMP 目的不可达）</p></li></ul><h4 id="静态路由配置及其可能产生的路由环路问题">静态路由配置及其可能产生的路由环路问题</h4><ol><li>互指的错误<img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%9B%BE%202026-01-27%2016-08-46.webp" alt=""></li><li>路由汇总 + 错误聚合 <img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%9B%BE%202026-01-27%2016-21-36.webp" alt=""><br>针对情况2,使用黑洞路由解决。<br>如果路由器查表的时候有多条能够匹配，使用最精确的那一条</li></ol><ul><li><p><strong>正常流量 (如 192.168.1.1)：</strong></p><ul><li><p>路由器上有具体的明细路由（比如是通过动态路由学到的，或者是直连的）。</p></li><li><p>明细路由 <code>/24</code> 比 Null0 的汇总路由 <code>/16</code> 更长。</p></li><li><p><strong>结果：</strong> 正常转发，不会被丢弃。</p></li></ul></li><li><p><strong>异常流量 (如 192.168.3.1)：</strong></p><ul><li><p>路由器上没有 <code>.3.0</code> 的明细路由。</p></li><li><p>此时，它匹配到了我们刚写的 <code>192.168.0.0/16 -&gt; Null0</code>。</p></li><li><p>虽然可能还有默认路由指向外网，但 <code>/16</code> 比 <code>/0</code> (默认路由) 长。</p></li><li><p><strong>结果：</strong> 路由器直接把包扔进垃圾桶 (Null0)。<strong>环路被切断了！</strong></p></li></ul></li></ul><h4 id="路由选择协议">路由选择协议</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%9B%BE%202026-01-27%2016-29-19.webp" alt=""><br><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260127163236985.webp" alt="image.png"></p><h4 id="RIP的基本工作原理">RIP的基本工作原理</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260128071526869.webp" alt="image.png"></p><h5 id="更新过程">更新过程</h5><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260129072049415.webp" alt="image.png"></p><ol><li>路由器B收到了路由器A的路由表</li><li>改造信息： B收到了A的路由表后， 把所有的举例都加1, 下一跳都改为A（B是A的相邻表，距离加1跳）<br>更新原则：<ul><li><strong>新路线</strong>： A知道网络X怎么去，距离是x， B不知道， 直接添加</li><li><strong>更短路线</strong>： A到网络Y要2跳，B到Y原本走C要5跳，更新，以后到Y走A</li><li><strong>同源更新</strong>： A到网络Z需要10, B原本就是走A到Z的只需要3跳， 更新</li><li><strong>更差的路线</strong>： 不管</li></ul></li></ol><h5 id="RIP的缺点：坏消息传的慢（慢收敛）">RIP的缺点：坏消息传的慢（慢收敛）</h5><ol><li><p>路由器 A 连着网络 N，A 告诉 B：“去 N 只要 1 跳”。</p></li><li><p>B 告诉 C：“去 N 只要 2 跳”。</p></li><li><p>突然，<strong>A 和 N 断了</strong>。A 将去 N 的距离改为 16（不可达）。</p></li><li><p>但在 A 的更新包发给 B 之前，B 抢先给了 A 一个更新：“嘿，去 N 走我这里只要 2 跳哦！”（这是 B 之前从 A 那里听来的旧闻）。</p></li><li><p>A 傻了：“哦？你能去 N？那我把数据给你，距离变成 3。”</p></li><li><p>A 和 B 开始互相欺骗，距离从 3 涨到 4，4 涨到 5… 直到涨到 16。</p></li><li><p>这就是 <strong>“计数到无穷” (Count-to-Infinity)</strong> 问题，形成了路由环路。<br><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260129102724434.webp" alt="image.png"></p></li></ol><h4 id="OSPF的基本工作原理">OSPF的基本工作原理</h4><ul><li>OSPF是基于链路状态的，而不是像RIP一样基于距离向量</li><li>采用Dijkstra提出的最短路径算法SPF计算路由， 从算法上保证了不会产生路由环路</li><li>不限制网络规模， 更新效率高，收敛速度块</li><li>链路状态是指本路由器和哪些路由器相邻以及相映链路的“代价“</li></ul><h5 id="工作流程">工作流程</h5><ol><li>建立邻居关系<br>相邻路由器通过交互问候（hello)分组， 建立和维护邻居关系<ul><li><p><strong>动作：</strong> 只要两个路由器互相收到了对方的 Hello 包，它们就建立了<strong>邻居关系 (Neighbor Relationship)</strong>。</p></li><li><p><strong>目的：</strong> 确认链路是通的，并确立“我们俩要开始交换信息了”。</p></li><li><p><strong>维持：</strong> 之后也会周期性发送 Hello 包（通常 10秒一次）作为“心跳”，如果 40秒（Dead Time）没收到邻居的 Hello，就认为邻居挂了。</p></li></ul></li><li>链路状态洪泛<br>使用OSPF的路由器会产生链路状态通告（LSA)， LSA中包含直连网络的状态信息， 相邻路由器的链路状态信息，与相邻路由器间的”代价“<ul><li><p><strong>泛洪 (Flooding)：</strong> 每个路由器都会把自己的 LSA 发给邻居，邻居收到后，<strong>原封不动</strong>地拷贝一份发给它的邻居。</p></li><li><p><em>结果：</em> 就像连锁反应一样，最终全网所有的路由器都收到了<strong>每一台</strong>路由器的 LSA。</p></li></ul></li><li>构建链路状态数据库（LSDB)<br>将收集到的LSA存到数据库中</li><li>计算最短路径<br>有了LSDB，路由器开始运行 <strong>Dijkstra 算法</strong>，构建出到达其他各路由的最短路径， 即构建路由表</li></ol><h5 id="区域">区域</h5><p>如果网络特别大， LSDB会变得巨大， 为了使SPF可以用于大规模的网络，OSPF把一个自治系统划分为若干小范围的系统，叫做区域<br><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260129105832875.webp" alt="image.png"></p><h4 id="边界网关协议BGP">边界网关协议BGP</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260129110828473.webp" alt="image.png"><br>BGP 是目前互联网上<strong>唯一</strong>使用的 <strong>EGP (外部网关协议)</strong>。它的核心任务不是“找最快的路”，而是**“找一条能走、且符合策略（Policy）的路”**<br><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260129125135371.webp" alt="image.png"></p><h4 id="IPv4数据报的首部格式">IPv4数据报的首部格式</h4><h4 id="网际控制报文协议ICMP">网际控制报文协议ICMP</h4><ol><li>终点不可达</li><li>源点抑制<br>路由器或主机由于拥塞而丢弃数据时，向源点发送源点抑制报文，使源点知道应当把数据报的发送速率减缓</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）</li></ol><h5 id="以下情况不发送ICMP">以下情况不发送ICMP</h5><ul><li>对ICMP差错报告报文不发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.1或0.0.0.0）的数据报不发送</li></ul><h5 id="常见的ICMP询问报文">常见的ICMP询问报文</h5><ul><li>回送请求和回答<br>由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<br>这种报文用于测试目的站是否可达</li><li>时间戳请求和回答<br>请某个主机或路由器回答当前的日期和时间<br>进行时间同步和测量时间</li></ul><h5 id="ICMP应用">ICMP应用</h5><ul><li>ping</li><li>traceroute</li></ul><h4 id="虚拟专用网VPN与网络地址转换NAT">虚拟专用网VPN与网络地址转换NAT</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260129190318836.webp" alt="image.png"></p><h3 id="运输层">运输层</h3><h4 id="UDP与TCP对比">UDP与TCP对比</h4><p>UDP(user datagram protocal) tcp(transmission control protocal)<br>UDP</p><ul><li>无连接</li><li>支持一对一， 一对多，多对多，多对一交互通信</li><li>对应用层交付的报文直接打包</li><li>尽最大努力交付，不可靠，不使用流量控制和拥塞控制</li><li>首部开销小，只有8个字节<br>TCP</li><li>面向连接</li><li>只能一对一传输</li><li>面向字节流</li><li>可靠传输，使用流量控制拥塞控制</li><li>首部最小20字节，最大60字节</li></ul><h4 id="TCP的流量控制">TCP的流量控制</h4><p>如果发送方发送数据过快，接收方可能来不及接受，这回导致数据的丢失。<br>流量控制就是让发送方的速率不要太快，让接收方来的及接收<br>利用滑动窗口机制可以在TCP上实现对发送方的流量控制</p><h5 id="滑动窗口">滑动窗口</h5><ul><li>接收方每次发送确认报文的时候，都会在窗口字段填入当前自己的缓冲区还有多少空间</li><li>发送方收到ACK后，更新自己的发送窗口，保证已经发送但未收到确认的数据量&lt;=接收方的通知窗口大小</li><li>接收方读取了缓冲区的数据，有更多的空间，会发送一个新的ACK告诉发送方，发送方的窗口向右滑动，继续发送</li></ul><h6 id="窗口关闭">窗口关闭</h6><p>如果接收方缓冲区已经满了，会发送一个窗口为0的报文，此时发送方停止发送<br>但是这又有一个新的问题，<em>如果接收方处理了数据，有空余的空间，发送一个窗口增加的报文，但是这个报文在网络中丢失了，怎么办？</em> 这会导致死锁<br>解决方案：窗口关闭时，发送方启动一个定时器，周期性的向接收方发送一个字节数的探测报文，接收方收到后必须回复当前窗口的大小，这样就不会死锁</p><h4 id="TCP的拥塞控制">TCP的拥塞控制</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260130215616083.webp" alt="image.png"></p><p>拥塞控制是一个不断试探网络的过程，一旦发现丢包，就立即减少发送量，然后再慢慢增加</p><p>关键变量：<strong><code>cwnd</code> (拥塞窗口)</strong> 和 <strong><code>ssthresh</code> (慢启动阈值)</strong></p><p>cwnd: 发送方可以发送的数据量，不考虑接受方能不能接受<br>ssthresh：是慢启动与拥塞避免阶段的分界</p><ol><li><p>慢启动<br>刚开始建立连接时，不知道网络状况什么样，从极小的大小开始试探<br>初始cwnd=1,发送数据，每收到一个ACK就+1<br>每次窗口都翻倍增长<br>当cwnd增长到&gt;=ssthresh时，慢启动结束，进入拥塞避免阶段</p></li><li><p>拥塞避免<br>不再翻倍增长，而是每经过一个发送确认周期，cwnd大小只增加1<br>直到网络出现丢包结束</p></li><li><p>拥塞发生</p><ol><li>严重拥塞<br>发送方迟迟收不到 ACK，直到定时器（RTO）超时。TCP 认为网络可能瘫痪了，反应非常剧烈。<br>ssthresh设置为当前cwnd的一半，然后将cwnd大小重置为1，重新进入慢启动阶段</li><li>轻微拥塞<br>发送方收到了连续3个重复的ACK（这说明中间有包丢失了，但是后面的都收到了），TCP认为网络还行，不需要重置为1,进行快重传，快恢复<ul><li>ssthresh设置为cwnd的一半</li><li>将cwnd设置为ssthresh + 3(3是那三个重复的ACK)</li><li>进入快恢复</li></ul></li></ol></li><li><p>快恢复</p><ul><li><p>如果继续收到<strong>重复的 ACK</strong>，说明还有后续数据包到达了（都在网络里），<code>cwnd</code> 继续 <strong>+1</strong>。</p></li><li><p>直到收到<strong>新的 ACK</strong>（确认了重传的数据包），说明丢包已经补上了。</p></li><li><p><strong>退出快恢复</strong>：将 <code>cwnd</code> 设置为 <code>ssthresh</code>（即刚才减半后的值），然后<strong>进入拥塞避免</strong>阶段（线性增长）。</p></li></ul></li></ol><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260131164803359.webp" alt="image.png"></p><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260131165106744.webp" alt="image.png"></p><h4 id="TCP超时重传">TCP超时重传</h4><p>TCP 超时重传时间 (<strong>RTO</strong>, Retransmission TimeOut)<br>RTT：数据包从发送到收到ACK的往返时间<br>如果RTO设置的时间太短，没有丢包也会认为丢包，产生不必要的重传，如果设置的时间太长，真发生丢包的时候，重传太慢，效率也很低</p><p>TCP采用动态算法计算RTO，让RTO的时间略大与RTT</p><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260201130635137.webp" alt="image.png"></p><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260201130821907.webp" alt="image.png"></p><h4 id="TCP的连接建立">TCP的连接建立</h4><p>三次握手<br><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260202203943311.webp" alt="image.png"></p><ul><li>最初都处于close状态</li><li>TCP服务器进程首先创建传输控制快，然后等待TCP客户端的连接请求，进入监听状态，</li><li>客户端随机生成一个初始序列号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。发送报文。<strong>报文内容：</strong> <code>SYN=1</code>, <code>seq=x</code></li><li>服务器收到请求，同意建立连接。它需要确认客户端的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，同时自己也生成一个初始序列号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>。<strong>报文内容：</strong> <code>SYN=1</code>, <code>ACK=1</code>, <code>seq=y</code>, <code>ack=x+1</code>。</li><li>客户端收到服务器的同意。需要对服务器的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 进行确认。<strong>报文内容：</strong> <code>ACK=1</code>, <code>seq=x+1</code>, <code>ack=y+1</code><ul><li>客户端发送后，进入 <strong><code>ESTABLISHED</code> (已建立连接)</strong> 状态。</li><li>服务器收到后，也进入 <strong><code>ESTABLISHED</code></strong> 状态<br><strong>为什么必须是“三次”，两次行不行？</strong><br>防止“已失效的连接请求”突然到达</li></ul></li></ul><ol><li><p>客户端发了第一个请求（A），但在网络里滞留了</p></li><li><p>客户端看 A 没回复，以为丢了，又发了一个请求（B）。</p></li><li><p>B 顺利完成了连接、传输、断开。</p></li><li><p><strong>过了一会儿，滞留的 A 终于到了服务器。</strong></p></li></ol><ul><li><p><strong>如果是两次握手：</strong> 服务器收到 A，以为客户端又要建新连接，立刻回复“好的”，连接就建立了。服务器开始傻等客户端发数据，浪费资源。</p></li><li><p><strong>如果是三次握手：</strong> 服务器收到 A，回复“好的”（第二次握手）。客户端收到后，发现：“咦？我没想建连接啊，这是旧消息。”于是客户端<strong>拒绝发送第三次确认</strong>。服务器收不到确认，就知道连接建立失败，释放资源。</p></li></ul><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p><h4 id="TCP连接关闭">TCP连接关闭</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/20260202210534344.webp" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMP</title>
      <link href="/2026/01/07/GMP/"/>
      <url>/2026/01/07/GMP/</url>
      
        <content type="html"><![CDATA[<h4 id="线程">线程</h4><p>内核态，操作系统的最小调度单元，创建销毁，调度都需要由内核来完成，可以充分利用多核，实现并行</p><h4 id="协程">协程</h4><ul><li>用户态，是线程的子集，在线程的基础上，对线程进行二次加工得到，从属于某一个线程，与线程存在映射关系比例是m : 1。</li><li>某一个协程陷入阻塞的话，这个阻塞会上升到整个线程</li></ul><blockquote><p>对操作系统而言，协程对它是透明的，它只能看到线程阻塞了<br>协程没法做到真正意义上的并行，只是在用户视角下的并发</p></blockquote><h4 id="goruntine">goruntine</h4><ul><li><p>golang对协程的优化，在goruntine和线程之间加了一个中间层，调度器，让协程不在依附于线程，实现动态组合关联，与线程的映射关系为M：N</p></li><li><p>继承了协程的优点，创建、销毁、调度都由用户态来完成，无需内核介入，更轻量</p></li><li><p>可以做到真正意义上的并行</p></li><li><p>某一个陷入阻塞的时候，会被调度器感知到，调度器会实现goruntine与线程的解绑释放资源<br><em><strong>为什么协程无法做到真正意义上的并行，而goruntine可以做到</strong></em></p></li><li><p>普通的协程是N：1关系，操作系统只看得到这一个线程，开了1000个协程，也只分配一个cpu核心的时间片，同一时刻只有一个协程在运行，属于并发但不是并行</p></li><li><p>go程序在启动的时候，会根据cpu核心数创建多个 P (Processor，逻辑处理器)。<br>每个 P 都会绑定一个系统线程 M (Machine)。<br>关键点：如果有 8 个 CPU 核心，Go 就会创建 8 个系统线程同时工作。调度器会把成千上万个 Goroutine 分发给这 8 个线程。<br>结果：物理上确实有 8 个 Goroutine 在同一纳秒内同时运行</p></li></ul><h3 id="GMP">GMP</h3><p>G：goruntine M:machine(内核视角下的线程) P:processor<br>对g而言，p相当于它的cpu，对m而言，p相当于它的执行代理，m要和p结合之后才能执行调度goruntine<br>对于每一个p而言，它会先尝试从自己的本地队列获取gorunine，每个p私有队列的话，可以设计到更少的并发，<strong>接近</strong>于无锁化,如果私有队列没有了，就去全局队列获取。如果本地队列以及全局队列都没有的话，就会尝试从其他的P的私有队列<strong>窃取</strong>，这涉及到并发问题，所以还是要加锁，所以说是接近无锁化</p><h3 id="核心数据结构">核心数据结构</h3><h3 id="G">G</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">m *m0,</span><br><span class="line"><span class="comment">///...</span></span><br><span class="line">sched buf,</span><br><span class="line"><span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="m0">m0</h4><p>m0是Go程序创建的第一个系统线程，</p><ul><li>唯一性：在整个 Go 进程的生命周期中，<code>m0</code> 是全局唯一的（它是定义在全局变量中的）。</li><li>静态分配：普通的 M 是在需要时动态创建（malloc）的，而 <code>m0</code> 是在程序启动之初就定义好的全局变量，不需要动态分配内存<br>作用：</li><li>负责Go程序的启动流程，调度器初始化，内存管理器初始化，垃圾回收器等，负责启动第一个goruntine执行main.main函数，之后参与正常的调度循环，与其他的m没区别。</li><li>在程序退出时还负责处理清理工作，比如等待其他goroutine结束、执行defer函数等</li></ul><h3 id="goruntine的生命周期">goruntine的生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  __ _Gsyscall  __</span><br><span class="line">/                  \ </span><br><span class="line">_Gidle --&gt; _Gdead --&gt; _GRunnable --&gt; _GRunning --&gt; _Gdead</span><br><span class="line">\                  /</span><br><span class="line">  --  _Gwaiting --</span><br></pre></td></tr></table></figure><p>_ Gsyscall: 系统调用<br>_ Gwaiting：等待中，G被阻塞了（channel读写， select，mutex），此时的g不在队列中，必须被唤醒才能到grunnable</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">g0 *g，<span class="comment">//不执行函数，做其他的g的调度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">runhead <span class="type">uint32</span>,</span><br><span class="line">runtail <span class="type">uint32</span>,</span><br><span class="line">runq [<span class="number">256</span>]guintptr,</span><br><span class="line">runnext guintptr,</span><br><span class="line"><span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="g0">g0</h4><p>m0是全局唯一的，但是g0不是，每一个M（线程）都有一个属于自己的 <code>g0</code>。<br>g0不执行用户的代码，负责<strong>执行调度逻辑</strong>，包括决定下一个运行哪个g，创建新g，<br>g0有较大的栈8MB，普通的g只有2kb，因此，当g要进行以下操作时，必须先切换到g0：<br>寻找下一个g，调用newproc创建新的g，用户栈溢出时进行扩容，垃圾回收</p><p>g0与g的转换：g0 -&gt; g: gogo() ,<br>g -&gt; g0 :mcall()，systemstack()</p><h3 id="调度类型">调度类型</h3><h4 id="主动调度">主动调度</h4><p><strong><code>runtime.Gosched()</code></strong>：用户显式调用，G 的状态从 <code>_Grunning</code> 变为 <code>_Grunnable</code>，然后被放入<strong>全局队列</strong>。注意，主动放弃的 G 通常不放回本地队列，而是放全局，避免它立刻又被拿出来运行</p><h4 id="被动调度">被动调度</h4><p>当 G 执行某些阻塞操作时，运行时会调用 <code>gopark</code> 把当前 G 的状态从 <code>_Grunning</code> 改为 <code>_Gwaiting</code>，并将其从 M 上移除。M 此时变为空闲，可以去执行队列里的下一个 G</p><h4 id="正常调度">正常调度</h4><p>goruntine的代码逻辑正常执行完了，最后进行正常的销毁，调用m_call把执行权给到g0</p><h4 id="抢占调度">抢占调度</h4><p>某一个goruntine执行了太久时间，被全局监控者monitor g监控到，被强制和p解绑</p><h4 id="宏观调度视角">宏观调度视角</h4><p><img src="https://eurekayu.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%9B%BE%202026-01-08%2020-18-52.webp" alt=""></p><p>schedule()：调用findRunnable(),找到下一个要被执行的goruntine</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">gp, inheritTime, tryMakeP := findRunnable()</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findRunnable找m的顺序</p><ol><li>插队的，看看P的runnext字段有没有G，（每经历61次调度之后，需要优先处理一次全局队列防止饥饿）</li><li>看看P的runq本地队列里面有没有g，（CAS无锁，访问比较快）</li><li>去全局队列里面找，需要加锁</li><li>检查网络轮询器，看看有没有 G 是因为网络 I/O 阻塞的，现在已经准备好了（Ready）。如果有，把它变成 <code>_Grunnable</code> 拿过来</li><li>本地/全局/网络都没有，就去窃取别的P的本地私有队列，偷一半</li><li>还是没有找到，进入休眠状态，需要唤醒</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>主流排序算法</title>
      <link href="/2026/01/05/%E4%B8%BB%E6%B5%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2026/01/05/%E4%B8%BB%E6%B5%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>按照排序的依据，可以分为两类，比较类排序与非比较类排序</p><p>比较类排序是通过比较决定次序，快排，选择排序，插入排序都属于此类，比较类排序的优势是适用性，它不在乎数据的分布，只要能比较就能排，但是比较类排序的速度有上限，时间复杂度下界是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><p>非比较类排序包括，计数排序，桶排序，基数排序，不通过排序进行比较，这类算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，但是对数据类型限制比较大，而且因为用空间换时间，所以对数据的规模也有一定要求，此外，对数据的分布硬额比较敏感，如果分布不均匀（有的桶是空的，有的桶是满的），效率就会降低</p><h4 id="冒泡排序">冒泡排序</h4><p>原理：依次比较两个元素，顺序错误就交换，直到没有交换的为止<br>代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">//排序l - 1轮</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        swapped := flase</span><br><span class="line">        <span class="comment">//每轮的比较次数，前有的i轮让i和元素有序了</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; l - i - <span class="number">1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>] &#123;</span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">                swapped = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//某轮没有交换说明已经完成</span></span><br><span class="line">        <span class="keyword">if</span> !swapped &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：最快是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，即数组本身就是排好的，最差是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="插入排序">插入排序</h4><p>原理：扑克牌插牌的逻辑，把元素依次与已排序部分比较，插入合适的位置<br>代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        cur := nums[i]</span><br><span class="line">        j := i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; cur &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = cur</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序">选择排序</h4><p>原理：在未排序的序列找到最小的，放到未排序序列的起始位置，重复这个过程，直到所有都排序完<br>代码实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">select</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        minIdx := i</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[minIdx] &#123;</span><br><span class="line">                minIdx = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i], nums[minIdx] = nums[minIdx], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般不会使用，无论是什么样的数据，它的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，唯一的好处是不占用额外的空间</p><h4 id="希尔排序">希尔排序</h4><h4 id="归并排序">归并排序</h4><p>原理：分治法，把长度为N的序列分为N/2的两个序列，对这两个子序列进行排序，最后在合并为最终的序列<br>代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">    left := mergeSort(arr[:mid])</span><br><span class="line">    right := mergeSort(arr[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, left[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, right[j])</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">append</span>(res, left[i:]...)</span><br><span class="line">    res = <span class="built_in">append</span>(res, right[j:]...)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>,空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>, 合并的时候需要一个数组存放临时数据</p><h4 id="快速排序">快速排序</h4><p>原理：也是分治法，从数组中选一个元素作为基准，重新排列，比基准小的放前面，大的放后面<br>代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">        pivotIdx := partition(arr, left, right)</span><br><span class="line">        QuickSort(arr, left, pivotIdx - <span class="number">1</span>)</span><br><span class="line">        QuickSort(arr, pivotIdx + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">//随机选择 pivot 并交换到最右端</span></span><br><span class="line">randomIndex := left + rand.Intn(right-left+<span class="number">1</span>)</span><br><span class="line">arr[randomIndex], arr[right] = arr[right], arr[randomIndex]</span><br><span class="line"></span><br><span class="line">pivot := arr[right]</span><br><span class="line">i := left</span><br><span class="line"><span class="keyword">for</span> j := left; j &lt; right; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &lt; pivot &#123;</span><br><span class="line">arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i], arr[right] = arr[right], arr[i]</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：平均：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。最坏：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> （当数组有序且每次选第一个数为基准时，退化为冒泡）</p><h4 id="堆排序">堆排序</h4><h4 id="计数排序">计数排序</h4><h4 id="桶排序">桶排序</h4><h4 id="基数排序">基数排序</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>context原理</title>
      <link href="/2026/01/03/context/"/>
      <url>/2026/01/03/context/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/597234214">这篇文章</a>讲的太好了，自己记录一下加深印象</p><ul><li>主要用途：用于在异步场景并发协调以及对goruntinue的生命周期进行控制，传递取消信号，超时，截止时间，并且具有一定的数据存储能力</li><li></li></ul><h3 id="核心数据结构">核心数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)<span class="comment">//返回context的过期时间</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;<span class="comment">//返回一个channel，当Context被取消或超时，这个channel会关闭</span></span><br><span class="line">    Err() <span class="type">error</span><span class="comment">//返回错误</span></span><br><span class="line">    Value(key any) any<span class="comment">//在调用链中携带的键值对数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="emptyCtx">emptyCtx</h4><p>根基：是所有context的根</p><ul><li>类的实现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span>Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;<span class="keyword">return</span>&#125;</span><br></pre></td></tr></table></figure><p>常用的context.BackGround()与context.TODO()方法返回的都是emptyCtx</p><h4 id="cancelCtx">cancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    done atomic.Value</span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内嵌了一个context，所以可见cancelCtx必定是某个context的子context<br>children: 此cancelCtx的子context</p><ul><li>Deadline:cancelCtx并没有实现这个方法，只是内嵌了有Deadline()方法的Context，直接调用会报错</li><li>Done：</li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">   <span class="comment">//第一次Load，没有这一步，上来就加锁，成千上万个协程都要去抢锁，性能会很差</span></span><br><span class="line">d := c.done.Load()</span><br><span class="line"><span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">//有值直接返回</span></span><br><span class="line"><span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">d = c.done.Load()</span><br><span class="line">   <span class="comment">//为什么还要检查？确保channel只被创建一次</span></span><br><span class="line">   <span class="comment">//协程A，B同时调用Done()，第一次检查AB都发现d为nil，去抢锁，A拿到锁进去创建channel，然后解锁，此时b拿到锁，如果不Load()的话，B以为还是nil，会再创建一个channel把A建的覆盖</span></span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c.done.Store(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Err<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">err := c.err</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>Value<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value(c.Context, key)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>context.WithCancel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 WithCancel 创建它时，它不仅初始化了自己，还必须立刻寻找上级。使用propagateCancel，尝试将新节点加入到父节点的 children 列表中；如果父节点不支持列表（非标准实现），它就启动一个守护协程来通过 Channel 监听父节点的生死。</p><h5 id="propagateCancel">propagateCancel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="comment">// parent is already canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="timerCtx">timerCtx</h4><p>类</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它在cancel的基础上再进行封装，增加了一个time.Timer用于定时终止context，deadline用于timerCtx的过期时间</p><h5 id="timerCtx-cancel">timerCtx.cancel</h5><h5 id="context-WithTimeout-context-WithDeadline">context.WithTimeout &amp; context.WithDeadline</h5><h4 id="valueCtx">valueCtx</h4><p>类</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="valueCtx-Value">valueCtx.Value()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了value内部方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *valueCtx:</span><br><span class="line"><span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.val</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> *cancelCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> *timerCtx:</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">&#125;</span><br><span class="line">c = ctx.Context</span><br><span class="line"><span class="keyword">case</span> *emptyCtx:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> c.Value(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="valueCtx-WithValue">valueCtx.WithValue()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>channel底层实现</title>
      <link href="/2025/12/28/channel/"/>
      <url>/2025/12/28/channel/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构">数据结构</h3><p><code>Channel</code>在运行时使用hchan结构体，结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount <span class="type">uint</span> <span class="comment">//队列中当前元素的个数</span></span><br><span class="line">    dataqsiz kuint <span class="comment">//环形队列的总容量</span></span><br><span class="line">    buf unsafe.Pointer <span class="comment">//指向底层环形数组的指针</span></span><br><span class="line"></span><br><span class="line">    elemsize <span class="type">uint16</span> <span class="comment">//元素的大小</span></span><br><span class="line">    elemtype *_type <span class="comment">//元素的类型信息</span></span><br><span class="line"></span><br><span class="line">    sendx <span class="type">uint</span> <span class="comment">//发送索引，下一次发送写入的位置</span></span><br><span class="line">    recvq <span class="type">uint</span> <span class="comment">//接受索引，下一次接收读取的位置</span></span><br><span class="line"></span><br><span class="line">    recvq waitq <span class="comment">//双向链表，等待接收的goruntine队列</span></span><br><span class="line">    sendq waitq <span class="comment">//等待发送的goruntine队列</span></span><br><span class="line"></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，保护结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>recvq 和 sendq 的作用是存储那些“因为无法立即完成操作”而被迫阻塞（睡眠）的 Goroutine</p><ul><li>recvq:想读数据但读不到的 Goroutine</li><li>sendq:想发数据但发不出去的 Goroutine</li></ul><h4 id="waitq-阻塞的协程队列">waitq:阻塞的协程队列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog <span class="comment">//队列头部</span></span><br><span class="line">last *sudog <span class="comment">//尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sudog是对goruntine的再封装</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">g *g</span><br><span class="line"><span class="comment">//双向链表</span></span><br><span class="line">next *sudog</span><br><span class="line">prev *sudog</span><br><span class="line"></span><br><span class="line">elem unsafe.Pointer</span><br><span class="line">isSelect <span class="type">bool</span><span class="comment">//是不是select的标识，如果处于select里，即使条件不满足，也不要直接阻塞</span></span><br><span class="line"></span><br><span class="line">c *hchan<span class="comment">//指向它所从属的channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel的三种类型">channel的三种类型</h3><ul><li>无缓冲区</li><li>有缓冲区</li><li>缓冲区为指针类型的<br>底层通过makechan创建channel</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;  </span><br><span class="line">    elem := t.Elem  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// compiler checks this but be safe.  </span></span><br><span class="line">    <span class="keyword">if</span> elem.Size_ &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;  </span><br><span class="line">       throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.Align_ &gt; maxAlign &#123;  </span><br><span class="line">       throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    mem, overflow := math.MulUintptr(elem.Size_, <span class="type">uintptr</span>(size))  </span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;  </span><br><span class="line">       <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.  </span></span><br><span class="line">     <span class="comment">// buf points into the same allocation, elemtype is persistent.    // SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.    // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.     </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> c *hchan  </span><br><span class="line">    <span class="keyword">switch</span> &#123;  </span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:  </span><br><span class="line">       <span class="comment">// Queue or element size is zero.  </span></span><br><span class="line">       c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))  </span><br><span class="line">       <span class="comment">// Race detector uses this location for synchronization.  </span></span><br><span class="line">       c.buf = c.raceaddr()  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> !elem.Pointers():  </span><br><span class="line">       <span class="comment">// Elements do not contain pointers.  </span></span><br><span class="line">       <span class="comment">// Allocate hchan and buf in one call.      </span></span><br><span class="line">       c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">       c.buf = add(unsafe.Pointer(c), hchanSize)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">       <span class="comment">// Elements contain pointers.  </span></span><br><span class="line">       c = <span class="built_in">new</span>(hchan)  </span><br><span class="line">       c.buf = mallocgc(mem, elem, <span class="literal">true</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.Size_)  </span><br><span class="line">    c.elemtype = elem  </span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)  </span><br><span class="line">    <span class="keyword">if</span> b := getg().bubble; b != <span class="literal">nil</span> &#123;  </span><br><span class="line">       c.bubble = b  </span><br><span class="line">    &#125;  </span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> debugChan &#123;  </span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.Size_, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> c  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作流程">工作流程</h3><ol><li><p>写数据 ch &lt;- data</p><p>在开始写数据之前，会先处理特殊情况</p><ol><li>如果向一个空Channel写数据，会直接调用runtime.gopark，让出处理器的使用（也就是永远挂起）</li><li>如果channel已经关闭，立刻返回</li></ol> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//向一个没有经过初始化的channel写数据，会永远挂起</span></span><br><span class="line">   <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///...</span></span><br><span class="line">   lock(&amp;c.lock)</span><br><span class="line">   <span class="comment">//向一个已经关闭的写数据，会panic</span></span><br><span class="line">   <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;  </span><br><span class="line">    unlock(&amp;c.lock)  </span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>存在阻塞等待读goruntine<br>意味着缓冲区是空的或者就是没有缓冲区，否则不会有阻塞等待的goruntine<br>加锁-&gt;将写的数据直接给等待读的goruntine -&gt; 解锁 -&gt; 唤醒已经得到数据的goruntine</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> lock(&amp;c.lock)</span><br><span class="line"> <span class="comment">//从阻塞的读队列取出一个被封装为sudog的读goruntine</span></span><br><span class="line"> <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;  </span><br><span class="line">   <span class="comment">// Found a waiting receiver. We pass the value we want to send  </span></span><br><span class="line">   <span class="comment">// directly to the receiver, bypassing the channel buffer (if any). </span></span><br><span class="line">      <span class="comment">//send方法会基于memmove方法，将元素直接拷贝给sudog对应的goruntine</span></span><br><span class="line">      <span class="comment">//并且send方法会完成解锁动作</span></span><br><span class="line">    send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没有阻塞但是环形缓冲区仍然有空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;  </span><br><span class="line">   <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.  </span></span><br><span class="line">    qp := chanbuf(c, c.sendx)  </span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;  </span><br><span class="line">       racenotify(c, c.sendx, <span class="literal">nil</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    typedmemmove(c.elemtype, qp, ep)  </span><br><span class="line">    c.sendx++  </span><br><span class="line">    <span class="comment">//环形</span></span><br><span class="line">    <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;  </span><br><span class="line">       c.sendx = <span class="number">0</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    c.qcount++  </span><br><span class="line">    unlock(&amp;c.lock)  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写时没有阻塞读goruntine，且环形缓冲区没有空间<br>把当前写的goruntine放到阻塞的队列</p></li></ul> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.  </span></span><br><span class="line">gp := getg()  </span><br><span class="line">mysg := acquireSudog()  </span><br><span class="line">mysg.releasetime = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;  </span><br><span class="line">    mysg.releasetime = <span class="number">-1</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//封装构造goruntine的sudog</span></span><br><span class="line">mysg.elem = ep  </span><br><span class="line">mysg.waitlink = <span class="literal">nil</span>  </span><br><span class="line">mysg.g = gp  </span><br><span class="line">mysg.isSelect = <span class="literal">false</span>  </span><br><span class="line">mysg.c = c  </span><br><span class="line">gp.waiting = mysg  </span><br><span class="line">gp.param = <span class="literal">nil</span>  </span><br><span class="line">c.sendq.enqueue(mysg)  </span><br><span class="line"></span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)  </span><br><span class="line">reason := waitReasonChanSend  </span><br><span class="line"><span class="keyword">if</span> c.bubble != <span class="literal">nil</span> &#123;  </span><br><span class="line">    reason = waitReasonSynctestChanSend  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//现在应该陷入一个waiting的状态，等待读goruntine的读取</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanSend, <span class="number">2</span>)  </span><br><span class="line"><span class="comment">// Ensure the value being sent is kept alive until the  </span></span><br><span class="line"><span class="comment">// receiver copies it out. The sudog has a pointer to the  </span></span><br><span class="line"><span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the  </span></span><br><span class="line"><span class="comment">// stack tracer.  </span></span><br><span class="line">KeepAlive(ep)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// someone woke us up.  </span></span><br><span class="line"><span class="comment">// sudog被唤醒</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;  </span><br><span class="line">    throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">gp.waiting = <span class="literal">nil</span>  </span><br><span class="line">gp.activeStackChans = <span class="literal">false</span>  </span><br><span class="line">closed := !mysg.success </span><br><span class="line">gp.param = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;  </span><br><span class="line">    blockevent(mysg.releasetime-t0, <span class="number">2</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">mysg.c = <span class="literal">nil</span>  </span><br><span class="line">releaseSudog(mysg)  </span><br><span class="line"><span class="keyword">if</span> closed &#123;  </span><br><span class="line">    <span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;  </span><br><span class="line">       throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>      </span><br></pre></td></tr></table></figure><ol start="2"><li>读操作<br>如果如果向一个空Channel读数据，会直接调用runtime.gopark，让出处理器的使用（也就是永远挂起）<br>读一个已经关闭的channel，并且里面没有元素了，会读到零值 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果读得时候有阻塞的写协程<br>上锁 -&gt; 把缓冲区的第一个goruntine读出来 -&gt;把阻塞等待的写goruntine转移到环形缓冲区的尾部 -&gt; 解锁 -&gt; 把写goruntine唤醒</li><li>读没有阻塞的，并且缓冲区有空间  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;  </span><br><span class="line">   <span class="comment">// Receive directly from queue  </span></span><br><span class="line">    qp := chanbuf(c, c.recvx)  </span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;  </span><br><span class="line">       racenotify(c, c.recvx, <span class="literal">nil</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;  </span><br><span class="line">       typedmemmove(c.elemtype, ep, qp)  </span><br><span class="line">    &#125;  </span><br><span class="line">    typedmemclr(c.elemtype, qp)  </span><br><span class="line">    c.recvx++  </span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;  </span><br><span class="line">       c.recvx = <span class="number">0</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    c.qcount--  </span><br><span class="line">    unlock(&amp;c.lock)  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>读时没有阻塞写goruntine并且缓冲区没有元素<br>把当前的goruntine封装为sudog，然后这个读goruntine将会被放到阻塞等待的队列，然后gopark挂起，等待写goruntine向里面写数据唤醒</li></ul></li></ol><h3 id="阻塞模式与非阻塞模式">阻塞模式与非阻塞模式</h3><p>多路复用情况下，会变成非阻塞模式，不能因为一个分支就把goruntine挂起，所以用block标识，在挂起操作前进行判断</p><h3 id="关闭">关闭</h3><h3 id="一道题目">一道题目</h3><p>要求实现一个 map：<br>（1）面向高并发；<br>（2）只存在插入和查询操作 O(1)；<br>（3）查询时，若 key 存在，直接返回 val；若 key 不存在，阻塞直到 key val 对被放入后，获取 val 返回； 等待指定时长仍未放入，返回超时错误；<br>（4）写出真实代码，不能有死锁或者 panic 风险.<br><a href="https://www.bilibili.com/video/BV1uv4y187p6/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=e5201fb199b25d68c383fec45484b73b">解答</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyConcurrentMap <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line">mp <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">keyToCh <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyConcurrentMap</span><span class="params">()</span></span> *MyConcurrentMap&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyConcurrentMap &#123;</span><br><span class="line">mp:<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">keyToCh: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyConcurrentMap)</span></span>Put(k, v <span class="type">int</span>) &#123;</span><br><span class="line">m.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.UnLock()</span><br><span class="line">m.mp[k] = v</span><br><span class="line">ch, ok := m.keyToCh[k]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyConcurrentMap)</span></span>Get(k <span class="type">int</span>, maxwaitingDuration time.Duration) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">m.Lock()</span><br><span class="line">v, ok := m.mp[k]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">m.UnLock()</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">ch, ok := m.keyToCh[k]</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">m.keyToCh[k] = ch</span><br><span class="line">&#125;</span><br><span class="line">tCtx, cancel := context.WithTineout(context.Background(), maxWaitingDuration)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">m.Unlock()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- tCtx.DOne():</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, tCtx.Err()</span><br><span class="line"><span class="keyword">case</span> &lt;- ch:</span><br><span class="line">&#125;</span><br><span class="line">m.Lock()</span><br><span class="line">v = m.mp[k]</span><br><span class="line">m.Unlock()</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>包的匿名导入</title>
      <link href="/2025/12/24/%E5%8C%85%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5/"/>
      <url>/2025/12/24/%E5%8C%85%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>作用：利用包的副作用，即执行包内的init函数，但是不直接使用该包导出的任何变量或函数</p><p>常见使用场景：</p><ul><li>数据库注册驱动</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="comment">// 匿名导入 MySQL 驱动</span></span><br><span class="line">    <span class="comment">// 我们代码里不需要直接写 mysql.Connect，所以用</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里可以直接使用 mysql 驱动，因为上面的匿名导入已经把它注册进去了</span></span><br><span class="line">    db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@/dbname&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：在包内部有一个init函数，这个内部init执行，data/sql就知道如何处理“mysql”类型的连接了</p><p>如果想换数据库，只需要改动import路径</p><ul><li>图片格式解码：如果需要读取PNG，JEPG图片，需要匿名导入包</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;image&quot;</span></span><br><span class="line">    _ <span class="string">&quot;image/png&quot;</span>  <span class="comment">// 注册 PNG 解码器</span></span><br><span class="line">    _ <span class="string">&quot;image/jpeg&quot;</span> <span class="comment">// 注册 JPEG 解码器</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := os.Open(<span class="string">&quot;avatar.png&quot;</span>)</span><br><span class="line">    img, _, _ := image.Decode(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HTTP性能分析<br>当需要分析Go程序性能时，只需要匿名导入net/http/pprof，它就会自动注册HTTP路由</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言圣经第9章-sync</title>
      <link href="/2025/12/23/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"/>
      <url>/2025/12/23/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><em><strong>不要使用共享数据来通信，使用通信来共享数据</strong></em></p><p>无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争</p><p>避免数据竞争的三种方式：</p><ol><li>不去’写’变量</li><li>避免多个goroutine访问变量，变量都被限定在一个goroutine中， 其他的goroutine使用channel来发送请求给指定goroutine去更新变量，这就是使用通信来共享变量，<ul><li>即使当一个变量无法在其整个生命周期内被绑定到一个独立的goroutine，绑定依然是并发问题的一个解决方案。例如在一条流水线上的goroutine之间共享变量是很普遍的行为，在这两者间会通过channel来传输地址信息。如果流水线的每一个阶段都能够避免在将变量传送到下一阶段后再去访问它，那么对这个变量的所有访问就是线性的。其效果是变量会被绑定到流水线的一个阶段，传送完之后被绑定到下一个，以此类推。这种规则有时被称为串行绑定。</li></ul></li><li>第三种避免数据竞争的方法是允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“互斥”</li></ol><h4 id="sync的原子性操作">sync的原子性操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not atomic!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    Deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">        Deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数在过多的取款操作同时执行时，balance可能瞬间小于0,导致一些并发的取款被拒绝，这里的问题是取款不是一个原子操作，里面有三个步骤<br>为了解决这个问题，最直接的想法是在Withdraw函数里面加锁，但是go的锁是不可重入的，这么做就会导致Withdraw拿着锁，等着Deposit执行，Dsposit等着拿到锁执行，这就会导致死锁</p><p>一个通用的解决方法是，将函数拆分为加锁的公开方法和一个不加锁的私有方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> balance &lt; <span class="number">0</span> &#123;</span><br><span class="line">        deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// insufficient funds</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    deposit(amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function requires that the lock be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount <span class="type">int</span>)</span></span> &#123; balance += amount &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>延迟双删</title>
      <link href="/2025/12/22/%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0/"/>
      <url>/2025/12/22/%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0/</url>
      
        <content type="html"><![CDATA[<p>sbCSDN，教的东西是错的，我对着绕了好一会儿</p><h4 id="旁路缓存">旁路缓存</h4><p>流程：</p><ul><li>写策略：先更新数据库里的数据，再删除缓存</li><li>读策略：如果命中缓存，直接返回数据，没有命中，则从数据库中读取，然后将数据写入缓存，再返回数据<br>缺点：存在极低概率的并发问题（读操作比写操作慢得多时，可能导致旧数据覆盖），且严重依赖“删除缓存”这一步的成功</li></ul><h4 id="延迟双删">延迟双删</h4><p>流程：删除缓存-&gt;更新数据库-&gt;休眠一会儿-&gt;再次删除数据</p><p>第二次删是解决在数据库更新中，其他线程读取到旧数据并写入缓存的问题，中间需要延迟的原因是等待读取了旧数据的线程把缓存写入</p><p><strong>既然数据库在更新过程中，其他线程读取的是旧数据，最后都需要第二次删除，那我为什么不留着缓存，这样还能减少数据库的压力</strong></p><blockquote><p>第一次删除实际是把读旧缓存变成了 读旧数据库 + 回写旧缓存，需要第一次删除其实是为了容错，防止缓存删除失败，造成的永久脏数据，有了第一次删除，即使后面都挂了，缓存也是空的，直接查数据库也可以获得正确的数据（或者是旧库的数据）</p></blockquote><p><strong>延迟双删不是有脏数据回流吗，如果延迟双删的第二次删除失败的话，他不是也会有永久脏数据吗？</strong></p><blockquote><p>从这个角度看，延迟双删在“防删除失败”这一点上，和“旁路缓存”的策略相比，没有任何优势，甚至更脆弱（因为它依赖两次删除都成功）。</p></blockquote><p>那为什么还要用延迟双删？它的底线在哪里？<br>既然都有风险，延迟双删存在的意义是什么？</p><p>我们要区分两种“错误”：</p><ul><li>A 类错误：逻辑时序错误（并发导致）</li></ul><p>特征：网络正常，Redis 正常，代码执行成功，但因为线程执行顺序不对，导致脏数据。</p><p>Cache Aside（先改库后删）：无法解决。</p><p>延迟双删：可以解决。</p><ul><li>B 类错误：IO 故障错误（网络/宕机导致）</li></ul><p>特征：执行失败。</p><p>Cache Aside：最后一步删除失败，凉凉。</p><p>延迟双删：最后一步删除失败，凉凉。</p><p><strong>那么如何解决第二次删除失败呢，这就需要消息队列的重试机制了</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言圣经-第七章-接口</title>
      <link href="/2025/12/19/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/12/19/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="动态类型与动态值">动态类型与动态值</h4><p>动态类型是接口值里的具体类型信息，动态值是具体类型的值</p><h4 id="接口值的比较">接口值的比较</h4><p>当且仅当两个接口都是nil，或者他们的动态类型相同并且动态值也根据这个动态类型的==操作符相等。</p><p>因为接口值是可以比较的，所以它可以作为map键或做为switch语句的操作数</p><p>如果两个接口值动态类型相同，但是这个动态类型是不可比较的（Slice）那么就会比较失败并panic</p><p><strong>一个包含nil指针的接口不等于nil接口</strong></p><ul><li>包含nil指针的接口，里面的nil指针有具体的类型，只是值是nil,所以这个接口实际不是nil，而nil接口里面什么都没有</li></ul><h4 id="类型断言">类型断言</h4><p>x.(T)：判断这个变量x是不是T类型</p><ul><li><p>断言的是具体类型（int, string …）</p><p>如果成功，可以调用这个具体类型的所有方法和属性<br>失败会panic</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line"></span><br><span class="line">f := w.(*os.File)<span class="comment">//断言成功，里面确实是*os.File类型，可以调用Close(), Name()等io.Writer接口没有的方法</span></span><br><span class="line">c := w.(*bytes.Buffer)<span class="comment">//失败，不是Buffer</span></span><br></pre></td></tr></table></figure></li><li><p>断言的是接口类型<br>T不是具体的类型，而是另一个接口，比如<code>io.ReadWriter</code><br>检查x里面的东西是不是实现了T这个接口<br>成功，动态类型和动态值没变，能调用的方法变了，失败panic<br>本来有一个Writer类型的w，里面是一个File对象，只能调用Write()方法，现在做类型断言<code>rw := w.(io.ReadWriter)</code>,现在里面的东西能Write，我猜测它可以Read（实现ReadWriter）<br>检查File对象确实有Read()方法，返回一个新变量，rw里面还是那个File对象，动态值没变，但是类型变为了io.ReadWriter</p></li></ul><h4 id="类型断言询问行为">类型断言询问行为</h4><ul><li>web服务器需要向网络连接（w, io.Writer）写入字符串，但是io.Writer接口只定义了Write([]byte)方法，为了适配接口，要将字符串强转为[]byte，这会在内存中分配一段新的空间并进行数据拷贝，虽然用后就丢掉，但是在服务器中，频繁的分配会影响性能</li></ul><p>虽然w的表面类型是io.Writer，但是底层的具体对象往往有强大的功能，比如net/http的网络连接，*os.File, *bytes.Buffer， 这些类型都有一个WriteString(s string)的方法，能直接把字符串写到底层， 不用转换为[]byte</p><p>不能保证所有的io.Writer都有WriteString， 需要一种试探的方法：在函数内定义一个临时接口stringWriter， 里面包含WriteString方法， w.(stringWriter)成功，说明底层对象实现了WriteString，直接调用此方法避免内存分配，如果失败，就老老实实的转[]byte再调用Write</p><p>Go标准库直接提供了io.WriterString(w, s)函数，所以不需要写上面的判断逻辑，它会自动帮你做这种优化</p><p>fmt.Fprintf也是这么做的，当fmt需要打印一个x时， 也会进行‘试探’，</p><ul><li><p>试探 x.(error)：你有 Error() 方法吗？如果有，我就把它当错误打印。</p></li><li><p>试探 x.(Stringer)：你有 String() 方法吗？如果有，我就调用它获取字符串来打印。</p></li><li><p>兜底：都没有？那我用反射（Reflection）去分析你的结构打印出来</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言圣经第六章-方法</title>
      <link href="/2025/12/17/%E6%96%B9%E6%B3%95/"/>
      <url>/2025/12/17/%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="基于指针对象的方法">基于指针对象的方法</h4><p>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。<br>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言圣经第五章-函数</title>
      <link href="/2025/12/16/%E5%87%BD%E6%95%B0/"/>
      <url>/2025/12/16/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="strings-Map">strings.Map</h4><ul><li>定义：<code>func Map(mapping func(rune) rune, s string) string</code></li><li>作用： 对字符串的每一个字符进行修改，替换或删除，生成一个新的字符串</li></ul><p>主要作用取决于mapping这个函数的返回值，如果返回一个新的合法字符，那么就会替换，如果返回原来的字符就不变，如果返回-1就删除这个字符</p><ul><li>为什么要使用strings.Map？自己使用for循环不也能做到这些吗<ol><li>可以处理UTF-8字符，go的字符串的底层是[]byte，如果直接使用循环遍历，处理中文会乱码。strings.Map会自动把字符串解码为Runes，适合处理中文等</li><li>更高效，strings.Map内部使用了strings.Builder，相比于循环拼接时更高效</li><li>使用函数值，我们可以将遍历结点的逻辑和操作结点的逻辑分离，使得我们可以复用遍历的逻辑，从而对结点进行不同的操作。</li></ol></li></ul><h3 id="匿名函数">匿名函数</h3><p>函数squares返回另一个类型为 func() int 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。</p><p>squares的例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</p><p>通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</p><h3 id="闭包对循环变量的捕获">闭包对循环变量的捕获</h3><p><strong>这是go1.22前的行为,在1.22之后，每次循环迭代，循环变量都会重新创建了，这个特性可以忽略了</strong></p><ul><li>当你在 for 循环里创建一个函数（闭包），并且这个函数里用到了循环变量（比如 dir），这个函数记下的不是当时那个 dir 的值，而是 dir 这个变量本身的地址。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    <span class="comment">//go的变量遮蔽，使用外部循环变量的值初始化，这样闭包捕获的就是这个内部的新变量，而不是一直在变得循环变量</span></span><br><span class="line">    dir := d <span class="comment">// <span class="doctag">NOTE:</span> necessary!</span></span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>) <span class="comment">// creates parent directories too</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">    rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么使用d赋值一个新的变量，而不是使用下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir) <span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer">defer</h3><ul><li>defer 关键字只负责延迟“最外层”的那个函数调用，而为了拿到那个被延迟执行的函数，Go 必须先“立即”执行前面的代码<br><code>defer trace(&quot;big&quot;)()</code>实际等同于</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">returnedFunc := trace(<span class="string">&quot;big&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> returnedFunc()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言圣经第四章-符合数据类型</title>
      <link href="/2025/12/15/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/12/15/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="4-1-数组">4.1 数组</h3><p>当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。<br>因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数</p><h3 id="4-2-Slice">4.2 Slice</h3><h4 id="数组与Slice的差异">数组与Slice的差异</h4><ul><li>外观：方括号里面有没有东西<ol><li>数组必须定长，必须告诉编译器有多大，或者让编译器自己去数<br>比如：<code>[3]int{1,2,3}</code>,<code>[...]int{1,2,3,4}</code></li></ol><blockquote><p>只要方括号里面有‘东西’，就是数组</p></blockquote><ol start="2"><li>方括号里面是空的，就是切片</li></ol></li><li>切片：隐式创建数组<br>当创建一个切片时，s := []int{1, 2, 3}，编译器做了两件事<ol><li>在内存里创建一个长度为3的匿名数组，里面存了[1,2,3]</li><li>创建一个切片结构体，让s的指针指向那个匿名数组的第一个元素</li></ol></li></ul><h4 id="切片不能用-比较">切片不能用<code>==</code>比较</h4><ol><li>递归引用<br>一个Slice甚至可以包含自身，切片是一个引用类型，比如切片A里面有个元素是切片B，切片B里面又有一个元素是切片A<br>如果GO允许使用<code>==</code>的话，程序就会无限的递归循环</li><li>安全性<ul><li>如果Slice支持 == （深度比较）<br>底层的元素可能被修改，比如把切片s当作key存入一个map，修改s一个元素，此时s的hash值也会发生变化，再也找不到对应的key，map的内部结构崩坏</li><li>如果Slice支持 == （浅比较，只比较指针地址）<br>这会有不一致性问题，因为数组的 == 是比内容，而切片的 == 却是比地址，所以go直接禁止了切片的==操作</li></ul></li></ol><blockquote><p>怎么解决？</p></blockquote><ul><li><p>标准库提供了高度优化的<code>bytes.Equal</code>函数来判断两个字节型slice是否相等<code>（[]byte）</code>，但是对于其他类型的slice，我们必须自己展开每个元素进行比较，自己写一个 equal 函数来循环比较，或者使用 bytes.Equal（仅限字节切片）。 注：在 Go 1.21+ 版本中，官方新增了 <code>slices.Equal</code> 函数，终于不用自己手写了。</p></li><li><p>Slice唯一合法的比较-和nil比较<br>nil slice和 empty slice的区别<br>声明： nil: var s []int || s = nil<br>s := []int{} || make([]int, 0)<br>底层：nil slice没有底层数组，而empty有底层数组，尽管为空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span> slice == <span class="literal">nil</span> <span class="comment">//true</span></span><br><span class="line">empty slice == <span class="literal">nil</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>如果要判断一个切片是不是空，不要用<code>if s == nil</code>，而要用<code>if len(s) == 0</code>，这样可以覆盖nil切片和空切片两种情况</p></li></ul><h3 id="Map">Map</h3><p>K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在</p><p><em>虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法</em></p><ul><li>在数学中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.1</mn><mo>+</mo><mn>0.2</mn></mrow><annotation encoding="application/x-tex">0.1 + 0.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.2</span></span></span></span> 肯定等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.3</mn></mrow><annotation encoding="application/x-tex">0.3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.3</span></span></span></span>。<br>但在计算机二进制中，浮点数往往是对小数的近似表示。如果有一点的误差，存进去的数据就取不出来了</li><li>NaN 不等于任何数，包括它自己，把 NaN 当作 Key 存进 Map 时，哈希表找到了对应的key，但是比对会失败，这个数据会永远的失联</li></ul><h3 id="struct">struct</h3><p>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的</p><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员</p><h4 id="结构体嵌入与匿名成员">结构体嵌入与匿名成员</h4><p>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接访问叶子属性而不需要给出完整的路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span>       <span class="comment">// equivalent to w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</p><p>w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields<br>w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields<br>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;Circle&#123;Point&#123;<span class="number">8</span>, <span class="number">8</span>&#125;, <span class="number">5</span>&#125;, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br><span class="line"></span><br><span class="line">w.X = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, w)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure><ul><li>匿名成员也有一个隐式的名字，所以不能同时包含两个相同类型的匿名成员，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员，但是像注释中的那种长形式（w.circle.point.X）会在外部包中被禁止，因为你无法访问到circle和point</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.X = <span class="number">8</span> <span class="comment">// equivalent to w.circle.point.X = 8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言圣经第三章-基础数据类型</title>
      <link href="/2025/12/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AC%A6%E5%8F%B7/"/>
      <url>/2025/12/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="3-1-整型">3.1 整型</h3><p>^操作符在go中有两个作用：</p><ol><li>作为两元操作符时：x ^ y，按位异或，不同为1,相同为0</li><li>作为前置应让运算符：^y，按位取反</li></ol><p>&amp;^: z= x &amp;^ y, 如果y在某个位置是1,就把x对应位置的数归零，如果y在某个位置是0,x对应的数字不变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]o %#[1]o\n&quot;</span>, o)</span><br></pre></td></tr></table></figure><ul><li>%[1]o: 以八进制打印第一个参数，[1]的意思是读取第一个参数，好处是不用多次传同一个参数</li><li>#： 对于对应进制会在前面强制补零</li></ul><p>字符使用%c打印，带单引号的字符使用%q打印</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ascii := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">unicode := <span class="string">&#x27;国&#x27;</span></span><br><span class="line">newline := <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]c %[1]q\n&quot;</span>, ascii)   <span class="comment">// &quot;97 a &#x27;a&#x27;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]c %[1]q\n&quot;</span>, unicode) <span class="comment">// &quot;22269 国 &#x27;国&#x27;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %[1]q\n&quot;</span>, newline)       <span class="comment">// &quot;10 &#x27;\n&#x27;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-浮点数">3.2 浮点数</h3><p>math提供了正无穷和负无穷，用于表示太大溢出的数字和除零的结果，以及NaN非数，一般用于表示无效的除法操作，或者Sqrt(-1)</p><h3 id="3-4-布尔型">3.4 布尔型</h3><p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值</p><p>&amp;&amp;的优先级比||高（助记：&amp;&amp;对应逻辑乘法，||对应逻辑加法，乘法比加法优先级要高）</p><h3 id="3-5-字符串">3.5 字符串</h3><p>字符串是不可变的，不可边指的是无法修改底层存放数据的区域，但是可以让变量指向一块新的内存区域</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;left foot&quot;</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">&quot;, right foot&quot;</span></span><br></pre></td></tr></table></figure><p>t := s 发生了一次浅拷贝，只复制了s的结构体，s,t都指向同一个内存块，这是字符串拷贝非常快的原因，不用复制底层数据</p><p><code>s += &quot;, right foot&quot;</code>，在内存中找一个新地址，先把旧数据复制过去，然后再把新的数据追加过去，然后更新s，最后的结果就是，s指向了新的地址，t指向的还是原来的地址</p><p>ASCII控制代码转义方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a      响铃</span><br><span class="line">\b      退格</span><br><span class="line">\f      换页</span><br><span class="line">\n      换行</span><br><span class="line">\r      回车</span><br><span class="line">\t      制表符</span><br><span class="line">\v      垂直制表符</span><br><span class="line">\&#x27;      单引号（只用在 &#x27;\&#x27;&#x27; 形式的rune符号面值中）</span><br><span class="line">\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）</span><br><span class="line">\\      反斜杠</span><br></pre></td></tr></table></figure><p>UTF-8<br>定长编码（UTF-32）：不管是字母A，还是复杂的汉字，通通占用4个字节，这很浪费空间<br>变长编码（UTF-8）：<br>如果是 ASCII 字符（英文、数字）：只占用 1 个字节。<br>如果是 常用字符（比如部分欧洲文字）：占用 2 个字节。<br>如果是 汉字、日文：通常占用 3 个字节。<br>如果是 Emoji 表情：占用 4 个字节。</p><p>UTF-8利用每个字节的前面几位来标识这个字节是否读完了</p><ul><li>以0开头：告诉电脑结束了，这是一个完整的字符，保证了兼容性，可以兼容老旧的ASCII文件</li><li>多个字节：<ul><li>110：表示后面还有一个字节（2字节）</li><li>1110：后面还有2个字节（3字节）</li><li>11110：后面还有3个字节（4字节）<br>后续的字节以10开头</li></ul></li></ul><p>UTF8解码：显式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%c\n&quot;</span>, i, r)</span><br><span class="line">    i += size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用`DecodeRuneInString返回两个值，r是字符本身，size对应r在采用UTF-8编码后的编码字节数目<br>隐式：Go的range循环，在处理字符串的时候，会自动隐式解码</p><blockquote><p>如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)             <span class="comment">// x is an int</span></span><br><span class="line">y, err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// base 10, up to 64 bits</span></span><br></pre></td></tr></table></figure><h3 id="3-6-常量">3.6 常量</h3><ul><li>iota常量生成器<br>第一个声明的常量所在的行，itoa为0, 然后在每一个有声明的行+1</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>原文： “对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，无类型整数常量转换为int，它的内存大小是不确定的”</p></blockquote><p><em><strong>写一个整数不告诉go是什么类型的时候，go会默认转为int类型，int是一个平台相关类型，<br>在32位系统， int = int32，<br>在64位系统，int = int64</strong></em></p><blockquote><p>原文： “但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128&quot;</p></blockquote><p>go中没有像int那样的通用float类型，所以无论是32还是64位的系统，永远转化为float64</p><p><strong>为什么区别对待？</strong></p><ul><li>整数通常用于数组下标，循环计数，这些操作依赖机器的字长</li><li>科学计算和数值算法对精度极其敏感。如果在 32 位机器上默认是 float32（精度低），而在 64 位机器上默认是 float64（精度高）。那么对科学计算的影响很大</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2025/11/29/%E7%BC%93%E5%AD%98/"/>
      <url>/2025/11/29/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>git #### 缓存雪崩：<br>缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</p><h4 id="缓存击穿：">缓存击穿：</h4><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</p><h4 id="缓存穿透：">缓存穿透：</h4><p>查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</p><ul><li>解决方案：SingleFlight（单次飞行）</li></ul><p>无论有多少个并发请求问同一个 Key，在“缓存失效”的那个瞬间，我只放一个请求去查数据库。其他请求全部阻塞等待，等第一个请求查回来，大家共享这个结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口型函数</title>
      <link href="/2025/11/28/%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/"/>
      <url>/2025/11/28/%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>最近在写极客兔兔的<a href="https://geektutu.com/post/geecache-day2.html">GeeCache</a>这个小项目，在里面遇到了一段不太理解的代码，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A GetterFunc implements Getter with a function.</span></span><br><span class="line"><span class="keyword">type</span> GetterFunc <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get implements Getter interface function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f GetterFunc)</span></span> Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> f(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合<a href="https://geektutu.com/post/7days-golang-q1.html">兔兔的讲解</a>,写一篇博客</p><blockquote><p>本质是实现多态</p></blockquote><p>接口只有一个方法，为什么不直接使用GetterFunc作为参数传进参数？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFromSource</span><span class="params">(fn GetterFunc, key <span class="type">string</span>)</span></span> []<span class="type">byte</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这意味着它只能接受函数，而不能接受一个更复杂的类型，比如一个带有内部连接状态的数据库连接对象DB<br>我只能这样用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetFromSource(<span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;xxx&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>而不能使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">GetFromSource(<span class="built_in">new</span>(DB), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果使用接口型函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GetterFunc <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f GetterFunc)</span></span> Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> f(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在就可以传函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetFromSource(GetterFunc(<span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;hi&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>传结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetFromSource(<span class="built_in">new</span>(DB), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>传普通函数（转换为GetterFunc）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line">GetFromSource(GetterFunc(fetch), <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2025/11/16/JWT/"/>
      <url>/2025/11/16/JWT/</url>
      
        <content type="html"><![CDATA[<p>JWT(JSON Web Token)是一个自包含，可签名额字符串，常用于鉴权<br>结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">HEADER</span><span class="selector-class">.PAYLOAD</span><span class="selector-class">.SIGNATURE</span></span><br></pre></td></tr></table></figure><p><em>HEADER</em>：描述算法如HS256<br><em>Patload(Claims)</em>: 放自定义字段和标准字段，比如用户ID，过期时间，这个是外部可读的<br><em>Signature</em>：对 header+payload 用密钥/私钥签名，保证不可篡改</p><ul><li>AccessToken: 短期，用于日常访问，包含用户信息</li><li>RefreshToken： 长期，用于换新的accessToken，包含少量信息</li></ul><p><strong>JWT工作流程</strong>: 用户登录服务器，后端签发accessToken和refreshToken，前端保存token，每次访问接口时带上token，后端验证accessToken,通过则返回数据，如果accessToken过期了，前端自动使用RefreshToken获取新的accessToken，如果refreshToken也过期了，用户要重新登陆</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2025/11/15/kmp/"/>
      <url>/2025/11/15/kmp/</url>
      
        <content type="html"><![CDATA[<p><strong>解决在主串中快速匹配子串的问题</strong><br>传统暴力算法每次失败都要从头开始，时间复杂度是$$ O(m * n) $$,效率比较差</p><blockquote><p>核心思想：利用已经匹配过的信息，避免主串指针回退，从而加速匹配<br><em><strong>KMP是如何实现优化的呢？</strong></em></p></blockquote><ul><li>前缀表<br><code>next[i] = 当 needle[0..i]</code>不匹配时，应跳回的下一个可匹配位置（前缀长度）</li></ul><p>假设我们匹配：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">主串：  ABC ABCDAB ABCDABCDABDE</span><br><span class="line">子串：     ABCDABD</span><br><span class="line"></span><br><span class="line">当匹配到：</span><br><span class="line"></span><br><span class="line">ABCDAB <span class="strong">**E**</span></span><br><span class="line">ABCDAB <span class="strong">**D**</span></span><br><span class="line"></span><br><span class="line">在 E != D 时：</span><br><span class="line"></span><br><span class="line">暴力算法会回到开头：</span><br><span class="line">   ABCDAB E</span><br><span class="line">-&gt; A</span><br></pre></td></tr></table></figure><p>但 KMP 会使用 next 数组得知：</p><p>已匹配的 “ABCDAB” 中前缀和后缀的最长相等部分是 “AB”（长度 2）</p><p>所以只需跳回到 needle[2] 继续匹配，而无须重来。</p><p>这大幅减少了重复比较。</p><blockquote><p><em><strong>为什么next数组可以帮助跳位置</strong></em><br>因为next[i]表示的是以 i 为结尾的子串中，最长相等前后缀的长度<br>当子串和主串遇到不相等的字符时，子串会回到前缀的后一个位置与主串继续比较</p></blockquote><hr><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">一个例题</a></p><ul><li>构造next数组,找出模式串内每个位置 i 的最长前后缀</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j] &#123;</span><br><span class="line">        j = next[j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>利用next进行匹配,当遇到不匹配：使用 next 数组跳转，而不是暴力回退</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(haystack); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j] &#123;</span><br><span class="line">        j = next[j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> haystack[i] == needle[j] &#123;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> j == n &#123;</span><br><span class="line">        <span class="keyword">return</span> i - n + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu挂载新分区</title>
      <link href="/2025/11/14/ubuntu%E6%96%B0%E5%A2%9E%E6%8C%82%E8%BD%BD%E5%8D%B7/"/>
      <url>/2025/11/14/ubuntu%E6%96%B0%E5%A2%9E%E6%8C%82%E8%BD%BD%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<p>我使用的是windows11与ubuntu22.04双系统，当时装ubuntu的时候还是以windows做主力的，所以内存只分了100G，现在ubuntu使用的越来越多，windows好几天才启动一次，100G的空间有点不够用了，就想扩容一下<br>最开始还是想直接分到根目录下的，找了找教程，有点麻烦，而且有挺大的风险，于是就找了这个替代方案</p><ul><li><p>从windows压缩空间：<br><code>win + x</code>进入磁盘管理，找到空闲空间比较大的盘，右键选择压缩卷，输入想要给ubuntu的空间大小<br>点击压缩，等待一会就可以看间出现了一块未分配的空间</p></li><li><p>在ubuntu上挂载：<br>打开disks，可以看见在windows创建出来的未分配空间，<br>点击下面的+创建新分区<br>创建分区时类型要选择Ext4</p></li><li><p>设置自动挂载<br>点击刚刚设置好得分区下面的齿轮图标，选择“编辑挂载选项”，关闭用户会话默认设置，勾选“在系统启动时挂载”，命名挂载点，确定</p></li><li><p>新挂载的分区默认只有root才能写入，所以要修改所有权<br><code>sudo mkdir 挂载点</code><br><code>sudo mount -a</code>挂载新分区<br><code>sudo chown -R username:username /你的挂载点的名称</code><br>重启一下，应该可以看见新的文件夹了</p></li><li><p>现在的系统盘与新挂载得分区还是隔离的，所以要自己主动管理大文件</p><p>可以把Downloads,Pictures，以及自己的项目等文件移动到新分区中<br><strong>不要移动apt或snap安装的程序</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这个命令会把 Downloads 文件夹“剪切”到 /mnt/data/</span><br><span class="line">mv ~/Downloads /mnt/data/</span><br><span class="line"># ln -s [真实文件位置] [你想创建的快捷方式位置]</span><br><span class="line">ln -s /mnt/data/Downloads ~/Downloads</span><br></pre></td></tr></table></figure><blockquote><p><em>创建分区类型时，如果我选择与windows共用，NTFS类型，会有什么缺点</em></p></blockquote><ul><li>最大的问题，没有Linux权限，当你把一个 NTFS 分区挂载到 Ubuntu 时，为了“兼容”，Linux 会“假装”所有文件都有权限，通常会把它们全部显示为 rwxrwxrwx (所有人可读可写可执行)<br>这将导致一系列问题</li><li>上面的“符号链接”方案将会失败</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2025/10/25/docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/10/25/docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="docker与虚拟机的区别">docker与虚拟机的区别</h3><p>虚拟机是模拟硬件创建虚拟操作系统，运行多个虚拟机就是运行多个操作系统，docker还是使用宿主机的操作系统</p><h3 id="容器与镜像">容器与镜像</h3><ul><li>镜像是程序安装包，容器是运行中的程序，一个镜像可以run出多个容器</li></ul><h3 id="常用命令">常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们可以使用</span></span><br><span class="line">docker pull images</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从仓库下载到本地，要启动镜像的容器输入`run`命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前容器列表</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启停止状态的容器</span></span><br><span class="line">docker start &lt;容器名称/容器ID&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止容器直接输入stop命令</span></span><br><span class="line"> docker stop &lt;容器名称/容器ID&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除：</span></span><br><span class="line">docker rm &lt;容器名称/容器ID&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">容器在停止后自动删除，我们可以在运行时添加--<span class="built_in">rm</span>参数：</span></span><br><span class="line">docker run --rm 镜像名称</span><br></pre></td></tr></table></figure><h3 id="构建镜像">构建镜像</h3><h4 id="dockerfile">dockerfile</h4><ul><li>FROM：<br>一个dockerfile必须以FROM指令开始<br>作用：指定基础镜像</li><li>COPY<br>作用：将你宿主机 (你电脑) 上的文件或目录，复制到镜像内部。</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式: COPY [宿主机路径] [镜像内路径]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/demo1-0.0.1-SNAPSHOT.jar app.jar</span></span><br></pre></td></tr></table></figure><ul><li>RUN<br>作用：在构建镜像的过程中，执行 shell 命令（比如安装软件）。</li><li>EXPOSE<br>作用：声明这个容器在运行时，会监听哪个端口。</li><li>ENTRYPOINT：定义容器的“主程序（入口）”。</li><li>CMD：定义默认参数。<br>如果 ENTRYPOINT 存在，CMD 的内容会作为参数传给 ENTRYPOINT。如果 ENTRYPOINT 不存在，CMD 才会作为主程序。</li></ul><h3 id="容器网络类型">容器网络类型</h3><p>docker安装后，会创建三个网络<br>使用<code>network ls</code>查看<br>可以看到默认情况下有bridge、host、none这三种网络类型</p><ul><li>none：本地环回网络，无法连接互联网</li><li>bridge网络：容器默认使用的网络类型，这是桥接网络，也是应用最广泛的网络类型<br>就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。</li><li>host网络： 当容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的：</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dp完全背包.md</title>
      <link href="/2025/10/19/dp%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>/2025/10/19/dp%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<ul><li>看代码随想录一直不太理解这两句话</li></ul><blockquote><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。<br>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p></blockquote><p>为什么是这样？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求组合数</span></span><br><span class="line"><span class="comment">// 外层循环：遍历物品（颜料）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">    <span class="comment">// 内层循环：遍历背包容量（货架格子）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> item; j &lt;= capacity; j++) &#123;</span><br><span class="line">        dp[j] += dp[j - item];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一轮 (拿出红色颜料)：你拿着红色颜料，从头到尾把货架上所有能刷的地方都刷一遍，更新一遍货架的状态。刷完后，你把红色颜料放回去，并且再也不碰它了。</p><p>第二轮 (拿出蓝色颜料)：你拿着蓝色颜料，在当前已经有了红色的货架的基础上，再把所有能刷的地方刷一遍。因为你固定了物品的使用顺序。你总是先用完所有可能的红色，再用蓝色，再用绿色。所以，你最终得到的方案里，颜色出现的顺序必然是 (红, 蓝, 绿)，你永远不会得到 (蓝, 红, 绿) 这样的方案。因为它忽略了物品的排列顺序，所以它是在计算组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求排列数</span></span><br><span class="line"><span class="comment">// 外层循环：遍历背包容量（货架格子）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= capacity; i++) &#123;</span><br><span class="line">    <span class="comment">// 内层循环：遍历物品（颜料）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= item) &#123;</span><br><span class="line">            dp[i] += dp[i - item];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这相当于你一个格子一个格子地去填。</p><p>第一轮 (填满容量为1的格子)：你问，要填满容量为1的格子，可以用什么颜料？你把所有可用的颜料（红、蓝、绿…）都试一遍，看看谁能填进去。</p><p>第二轮 (填满容量为2的格子)：你问，要填满容量为2的格子，可以怎么做？你可以拿出任何一种颜料，比如红色，然后去看容量为2-红色重量的格子之前是怎么被填满的，把那些方案拿过来，最后涂上红色。你也可以拿出蓝色，再去看…</p><p>…</p><p>为什么这样是求排列？ 因为它在计算每个容量 i 的方案数时，都允许放入任何一个物品。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（三）</title>
      <link href="/2025/10/05/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2025/10/05/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="聚合函数">聚合函数</h3><ul><li>对一组值进行计算，返回单个值，将多行数据压缩成一个统计结果</li></ul><h4 id="常用函数">常用函数</h4><ul><li><code>COUNT(*)</code>:统计行数</li><li><code>SUM(colum)</code></li><li><code>AVG(column)</code>：计算平均值</li><li><code>MAX(column)</code></li><li><code>MIN(column)</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算总员工数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算公司月薪总支出</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h3 id="GROUP-BY子句">GROUP BY子句</h3><p>用于将数据按一列或多列进行分组</p><blockquote><p>在SELECT语句中出现的列，并且没被聚合函数包裹都必须出现在GROUP BY子句中</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    grouping_column,</span><br><span class="line">    aggregate_function(column_to_aggregate)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    grouping_column;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="窗口函数">窗口函数</h3><p>不改变原始行数，在每一行后面添加聚合计算结果</p><p><code>GROUP BY</code>是进行分组压缩，输出组的结果<br>窗口函数是新添加一列计算结果</p><h4 id="OVER子句">OVER子句</h4><p>所有的窗口函数都是用OVER子句定义计算的窗口<br><code>OVER()</code>:窗口包含表中的所有行<br><code>OVER(PARTITION BY)</code>:将窗口内部按列分区<br><code>OVER(ORDER BY)</code>:定义窗口内的排序规则</p><h4 id="常用的窗口函数">常用的窗口函数</h4><p>聚合类: <code>AVG()</code>, <code>SUM()</code>, <code>COUNT()</code> 等聚合函数都可以用作窗口函数。</p><p>排名类:<br><code>RANK()</code>: 标准排名，并列时会跳过后续名次 (e.g., 1, 2, 2, 4)。</p><p><code>DENSE_RANK()</code>: 紧凑排名，并列时不会跳过后续名次 (e.g., 1, 2, 2, 3)。<br>计算每个员工在其部门内的薪水排名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    department,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="comment">-- 先按部门分区，再在部门内按薪水降序排列，然后计算排名</span></span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> salary_rank,</span><br><span class="line">    <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> dense_salary_rank</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees;</span><br></pre></td></tr></table></figure><h3 id="DAO模式">DAO模式</h3><p>数据通常存储在数据库里（MySQL、PostgreSQL、Oracle…），但业务逻辑代码（比如计算订单总价、校验用户权限）并不应该直接和数据库的 SQL 语句耦合。<br>如果业务逻辑层直接写一堆 Connection、Statement、ResultSet，会有几个问题：</p><ul><li><p>耦合度高：业务逻辑和数据库代码混在一起，难以维护。</p></li><li><p>可移植性差：换数据库（MySQL → Oracle）就得改很多地方。</p></li><li><p>测试困难：想单独测试业务逻辑很难，因为总是依赖真实数据库。<br>java中通常分为以下几层</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Controller (界面/接口层)</span><br><span class="line">    ↓</span><br><span class="line">Service (业务逻辑层)</span><br><span class="line">    ↓</span><br><span class="line">DAO (数据访问层)</span><br><span class="line">    ↓</span><br><span class="line">Database (数据库)</span><br></pre></td></tr></table></figure><p>DAO 一般包含以下部分：</p><ul><li><p>DAO 接口：定义数据访问的操作</p></li><li><p>DAO 实现类：实现具体的 SQL 查询、增删改查逻辑</p></li><li><p>实体类 (Entity/Model)：对应数据库表的一条记录</p></li></ul><p>代码流程分为以下几步<br>1.定义实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定义DAO接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(Connection connection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id=?&quot;</span>);</span><br><span class="line">            stmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                u.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                u.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                u.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在Service层中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DAO 就是抽象数据访问的中介层，它的思想是：<br>把数据库操作封装成一个独立模块（接口 + 实现类）。<br>上层（Service/Controller）只用方法，不关心底层 SQL 细节。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（二）</title>
      <link href="/2025/10/04/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/10/04/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="性能优化-索引">性能优化-索引</h2><ul><li>索引可以提升数据库查询性能</li><li>索引是预先创建的一种有序的数据结构</li></ul><h3 id="创建索引">创建索引</h3><p><code>CREATE INDEX index_name ON table_name (column_name);</code></p><h3 id="验证索引是否生效">验证索引是否生效</h3><p><code>EXPLAIN SELECT * FROM table_name WHERE indexed_column = 'some_value';</code></p><ul><li>Seq Scan表示使用全表扫描没用索引</li><li>Index Scan表示成功使用索引</li><li></li></ul><h3 id="索引的好处说完了，代价呢？">索引的好处说完了，代价呢？</h3><ol><li>空间成本：会占用额外的硬盘空间</li><li>维护成本：虽然增加了查询<code>SELECT</code>的速度,但是当数据库要<code>INSERT,UPDATE,DELETE</code>等操作时，还要额外操作索引，降低写操作的速度</li></ol><h3 id="使用原则">使用原则</h3><ul><li>给谁用<ul><li>出现在<code>WHERE</code>子句的列</li><li>使用<code>JOIN</code>d的列</li><li>使用<code>ORDER BY</code>的列</li></ul></li><li>谁慎用<ul><li>写的操作比较多的列</li><li>值的重复度比较高的列（比如值是性别）</li></ul></li></ul><h3 id="索引失效">索引失效</h3><p>通配符在前面的时候，索引会失效<br><code>WHERE name LIKE '张%'; </code>– 能使用索引 (从目录的’Z’部分开始找)。</p><p><code>WHERE name LIKE '%三'; </code>– 无法使用索引 (不知道从哪个字母开始找)，退化为全表扫描</p><blockquote><p>为什么有时候创建索引了但是没有使用?</p></blockquote><blockquote><p>数据库中有一个查询优化器 (Query Optimizer)，它会智能地判断使用索引的成本。<br>核心原因：当数据量非常小时，直接进行全表扫描（一眼看完一张小纸条）比先查索引再找数据（先看目录再翻页）的成本更低，效率更高。因此，优化器会智能地放弃使用索引。只有当数据量大到一定程度，索引的优势才会体现出来。</p></blockquote><h2 id="事务">事务</h2><blockquote><p>将多个操作打包，要么全部成功，要么全部失败的机制</p></blockquote><h3 id="核心命令">核心命令</h3><ul><li><code>BEGIN</code>：开启事务</li><li><code>COMMIT</code>：提交事务，将所有更改保存</li><li><code>ROLLBACK</code>：回滚事务</li><li></li></ul><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 2. 执行一系列操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3. 根据情况选择提交或回滚</span></span><br><span class="line"><span class="comment">-- 如果所有操作都成功:</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 如果中途发生错误或想取消:</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><h2 id="JDBC">JDBC</h2><p>依稀记得自己在寒假学java的时候看过这个课，也清楚的记得都忘光了</p><h3 id="什么是JDBC">什么是JDBC</h3><p>JDBC (Java Database Connectivity) 是Java提供的一套标准API，用于连接和操作关系型数据库。它本身是规范，需要由具体的JDBC驱动 (Driver) 来实现。</p><p>类比: JDBC是“普通话”规范，而PostgreSQL的JDBC驱动就是一个能将“普通话”翻译成“PostgreSQL方言”的翻译官。<br>使用maven添加依赖</p><h3 id="建立连接">建立连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://localhost:5432/database_name&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;your_username&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password)) &#123;</span><br><span class="line">    <span class="comment">// 在这里执行数据库操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行查询">执行查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="comment">// ... 在 try-with-resources 块中 ...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name FROM authors;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">     <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行写入">执行写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="comment">// ... 在 try-with-resources 块中 ...</span></span><br><span class="line"><span class="comment">// 使用 &#x27;?&#x27; 作为参数占位符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO authors(name) VALUES(?);&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">    <span class="comment">// 安全地绑定参数</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>, <span class="string">&quot;新作者&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行更新操作</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">    System.out.println(affectedRows + <span class="string">&quot; 行受影响。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为防止SQL注入，必须使用<code>PreparedStatement</code>它允许我们使用 ?作为参数占位符，然后安全地将变量绑定到这些占位符上，而不是像<code>Statement</code>那样手动拼接SQL字符串。这既安全又高效。</p></blockquote><h3 id="在java中管理事务">在java中管理事务</h3><details class="toggle" ><summary class="toggle-button" style="">点击打开</summary><div class="toggle-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://localhost:5432/learning_sql&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;postgres&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       setupDatabase();</span><br><span class="line">       System.out.println(<span class="string">&quot;事务演示&quot;</span>);</span><br><span class="line">       <span class="comment">//成功转账</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n[1.zhangsan 向 lisi 成功转账100.00]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账前账户信息：&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        transMoney(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">100.00</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账后账户余额&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        <span class="comment">//失败转账</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n[2.zhangsan 向 lisi 转账10000.00 失败]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账前账户信息：&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        transMoney(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">10000.00</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;转账失败后账户余额&quot;</span>);</span><br><span class="line">        selectAccounts();</span><br><span class="line">        System.out.println(<span class="string">&quot;演示结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transMoney</span> <span class="params">(String fromAccount, String toAccount, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">            <span class="comment">//关闭自动提交，开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//从转出账户中扣款</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">subtractSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance - ? WHERE name = ? AND balance &gt;= ?;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt1</span> <span class="operator">=</span> conn.prepareStatement(subtractSql)) &#123;</span><br><span class="line">                pstmt1.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">                pstmt1.setString(<span class="number">2</span>, fromAccount);</span><br><span class="line">                pstmt1.setDouble(<span class="number">3</span>, amount);</span><br><span class="line">                <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt1.executeUpdate();</span><br><span class="line">                <span class="keyword">if</span> (affectedRows == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;账户 &quot;</span> + fromAccount + <span class="string">&quot; 余额不足，无法转账。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;从账户 &quot;</span> + fromAccount + <span class="string">&quot; 扣款 &quot;</span> + amount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">addSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance + ? WHERE name = ?;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt2</span> <span class="operator">=</span> conn.prepareStatement(addSql)) &#123;</span><br><span class="line">                pstmt2.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">                pstmt2.setString(<span class="number">2</span>, toAccount);</span><br><span class="line">                pstmt2.executeUpdate();</span><br><span class="line">                System.out.println(<span class="string">&quot;向账户 &quot;</span> + toAccount + <span class="string">&quot; 增加 &quot;</span> + amount);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;转账成功:事务已经提交&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;转账失败:正在回滚事务...&quot;</span>);</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                    System.out.println(<span class="string">&quot;回滚成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;回滚失败&quot;</span>);</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                            conn.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                            ex.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">            <span class="comment">//如果存在就删除旧的表</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;DROP TABLE IF EXISTS accounts;&quot;</span>);</span><br><span class="line">            <span class="comment">//创建新表</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;CREATE TABLE accounts (id SERIAL PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, balance NUMERIC(10,2) NOT NULL);&quot;</span>);</span><br><span class="line">            <span class="comment">//插入初始数据</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;zhangsan&#x27;,1000.00);&quot;</span>);</span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;lisi&#x27;, 500.00);&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库初始化成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;数据库初始化失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectAccounts</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT name, balance FROM accounts ORDER BY name;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;账户： %s, 余额： %.2f\n&quot;</span>, rs.getString(<span class="string">&quot;name&quot;</span>), rs.getDouble(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣HOT100/最长回文子串</title>
      <link href="/2025/10/03/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2025/10/03/leetcode5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>比较难懂的一道题，我看题解看了半天才想明白<br><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=problem-list-v2&amp;envId=2cktkvj">题目链接</a><br>第一想法是暴力枚举所有的子串，然后判断是否回文，但是太过复杂，判断子串回文要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>,一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的子串，整体的时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，有点慢</p><h3 id="方法一：中心扩展法">方法一：中心扩展法</h3><p>回文串无论长短都是中心对称的，这个方法就是遍历中心，然后不断扩展，唯一注意的就是回文串长度是奇数还是偶数，奇数是以字符为中心，而偶数就是以字符间的缝隙为中心，所以循环遍历的条件是<code>i &lt; 2 * n - 1</code></p><h3 id="方法二：Manacher算法">方法二：Manacher算法</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>postgreSQL学习笔记（一）</title>
      <link href="/2025/10/03/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/10/03/postgreSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="postgreSQL学习笔记（一）">postgreSQL学习笔记（一）</h1><hr><h2 id="基础环境">基础环境</h2><ul><li>创建数据路<br><code>CREATE DATABASE datebase_name;</code></li><li>切换数据库<br><code>\c database_name;</code></li><li>查看表结构<br><code>\d table_name;</code></li><li>创建表<br><code>CREATE TABLE table_name;</code></li></ul><h2 id="数据操作">数据操作</h2><ul><li>插入数据：<code>INSERT INTO;</code></li><li>查询数据：<code>SELECT column1,column2 FROM table_name;</code></li><li>修改数据：<code>UPDATE table_name SET column1 = new_value1 WHERE condition;</code></li><li>删除数据：必须使用where指定删除哪一行，否则会删除整个表</li><li><code>DELETE FROM table_name WHERE condition;</code></li></ul><h2 id="数据查询与表的结构修改">数据查询与表的结构修改</h2><ul><li><p>条件查询<br><code>SEWLECT * FROM table_name WHERE condition1 AND/OR condition2;</code></p></li><li><p>结果排序<br><code>SELECT * FROM table_name ORDER BY column_name ASC/DESC</code><br><code>ASC</code>(默认):升序</p></li><li><p>修改结构<br><code>ALTER TABLE table_name ADD COLUMN column_name data_type</code></p></li><li><p>主键</p><blockquote><p>作用: 唯一标识表中的每一行，其值必须唯一且不能为空 (NOT NULL)。<br>添加方式: ALTER TABLE table_name ADD PRIMARY KEY (column_name);</p></blockquote></li><li><p>自动递增主键 (SERIAL):</p><blockquote><p>作用: PostgreSQL特有的类型，用于创建一个自动递增的整数主键。插入新数据时无需手动指定ID。</p></blockquote><p><code>id SERIAL PRIMARY KEY</code></p><blockquote><p>示例:<br><code>CREATE TABLE students (         id SERIAL PRIMARY KEY,         name VARCHAR(100)     );     -- 插入时无需提供id     INSERT INTO students (name) VALUES ('小明');</code></p></blockquote></li></ul><h2 id="多表联查">多表联查</h2><ul><li><h3 id="外键">外键</h3><pre><code>-作用: 用于将一张表中的列与另一张表的主键关联起来，保证数据的引用完整性。</code></pre><code>CREATE TABLE books (     id SERIAL PRIMARY KEY,     title VARCHAR(255),     author_id INT,     FOREIGN KEY (author_id) REFERENCES     authors(id) );</code></li><li><h3 id="JOIN">JOIN</h3><ul><li>内连接 <code>INNER JOIN</code><br>返回两张表中能通过关联条件匹配上的数据。</li><li>左连接 <code>LEFT JOIN</code><br>作用：返回左面表的所有记录，以及右边表中能匹配上的记录。如果右边表没有匹配项，则用 NULL 填充。</li></ul></li><li><h3 id="子查询">子查询</h3><ul><li>返回单个值的子查询：<ul><li>返回一个值可以使用’='等比较运算符</li><li><code>... WHERE column = (SELECT single_value_column FROM ...);</code></li></ul></li><li>返回列表的子查询：<ul><li>必须用 <code>IN</code> 或 <code>NOT IN</code></li><li><code>... WHERE column IN (SELECT list_column FROM ...);</code></li></ul></li></ul></li><li><h3 id="通用表表达式（CTE）">通用表表达式（CTE）</h3><ul><li>使用<code>WITH</code>关键字定义一个临时的查询结果集，将复杂的查询拆分</li><li><code>WITH cte_name AS ( SELECT ... -- 这里是子查询的逻辑 ) SELECT ... FROM cte_name ...; -- 在主查询中使用这个临时表</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
